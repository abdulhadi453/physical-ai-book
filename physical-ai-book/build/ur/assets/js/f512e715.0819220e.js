"use strict";(globalThis.webpackChunkai_native_textbook_physical_ai_humanoid_robotics=globalThis.webpackChunkai_native_textbook_physical_ai_humanoid_robotics||[]).push([[2731],{3822:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"chapter-3/safety-framework","title":"Safety and Reliability Framework for Isaac Sim AI-Robot Systems","description":"Overview","source":"@site/docs/chapter-3/safety-framework.md","sourceDirName":"chapter-3","slug":"/chapter-3/safety-framework","permalink":"/ur/docs/chapter-3/safety-framework","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapter-3/safety-framework.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"AI-Robot Communication Protocols for Isaac Sim","permalink":"/ur/docs/chapter-3/communication-protocols"},"next":{"title":"Performance Monitoring Tools for Isaac Sim AI-Robot Systems","permalink":"/ur/docs/chapter-3/performance-monitoring"}}');var s=n(4848),a=n(8453);const i={},l="Safety and Reliability Framework for Isaac Sim AI-Robot Systems",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Introduction to Safety and Reliability in AI-Robotics",id:"introduction-to-safety-and-reliability-in-ai-robotics",level:2},{value:"What is Safety and Reliability in AI-Robotics?",id:"what-is-safety-and-reliability-in-ai-robotics",level:3},{value:"Key Safety and Reliability Principles",id:"key-safety-and-reliability-principles",level:3},{value:"Safety Framework Components",id:"safety-framework-components",level:2},{value:"1. Creating Safety Monitor Node",id:"1-creating-safety-monitor-node",level:3},{value:"2. Creating Reliability Monitor Node",id:"2-creating-reliability-monitor-node",level:3},{value:"Fault Detection and Recovery",id:"fault-detection-and-recovery",level:2},{value:"1. Creating Fault Detection System",id:"1-creating-fault-detection-system",level:3},{value:"Safety and Reliability Launch Files",id:"safety-and-reliability-launch-files",level:2},{value:"1. Creating Safety Framework Package",id:"1-creating-safety-framework-package",level:3},{value:"2. Creating Setup Files for Safety Package",id:"2-creating-setup-files-for-safety-package",level:3},{value:"3. Creating Safety Framework Launch File",id:"3-creating-safety-framework-launch-file",level:3},{value:"Safety Configuration and Policies",id:"safety-configuration-and-policies",level:2},{value:"1. Creating Safety Configuration File",id:"1-creating-safety-configuration-file",level:3},{value:"Safety Testing and Validation",id:"safety-testing-and-validation",level:2},{value:"1. Creating Safety Test Scripts",id:"1-creating-safety-test-scripts",level:3},{value:"Safety Documentation and Procedures",id:"safety-documentation-and-procedures",level:2},{value:"1. Creating Safety Procedures Document",id:"1-creating-safety-procedures-document",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"1. Creating Safety Framework Test Script",id:"1-creating-safety-framework-test-script",level:3},{value:"2. Running Safety Framework Test",id:"2-running-safety-framework-test",level:3},{value:"Troubleshooting Safety Framework",id:"troubleshooting-safety-framework",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Issue: &quot;Safety monitor not responding to emergency conditions&quot;",id:"issue-safety-monitor-not-responding-to-emergency-conditions",level:4},{value:"Issue: &quot;High CPU usage from safety monitoring nodes&quot;",id:"issue-high-cpu-usage-from-safety-monitoring-nodes",level:4},{value:"Issue: &quot;False positive fault detections&quot;",id:"issue-false-positive-fault-detections",level:4},{value:"Verification Checklist",id:"verification-checklist",level:2},{value:"Next Steps",id:"next-steps",level:2}];function f(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"safety-and-reliability-framework-for-isaac-sim-ai-robot-systems",children:"Safety and Reliability Framework for Isaac Sim AI-Robot Systems"})}),"\n",(0,s.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(r.p,{children:"This document provides comprehensive guidelines for implementing safety and reliability frameworks in the NVIDIA Isaac Sim AI-robot systems for Module 3. The framework ensures that AI-robot systems operate safely and reliably in both simulation and real-world environments."}),"\n",(0,s.jsx)(r.h2,{id:"introduction-to-safety-and-reliability-in-ai-robotics",children:"Introduction to Safety and Reliability in AI-Robotics"}),"\n",(0,s.jsx)(r.h3,{id:"what-is-safety-and-reliability-in-ai-robotics",children:"What is Safety and Reliability in AI-Robotics?"}),"\n",(0,s.jsx)(r.p,{children:"Safety and reliability in AI-robotics encompasses:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Safety"}),": Ensuring the robot operates without causing harm to humans, environment, or itself"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Reliability"}),": Ensuring consistent, predictable operation under various conditions"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Robustness"}),": Maintaining functionality despite uncertainties and disturbances"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Fail-safe mechanisms"}),": Graceful degradation when failures occur"]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"key-safety-and-reliability-principles",children:"Key Safety and Reliability Principles"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Fail-Safe Design"}),": Systems default to safe states on failure"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Redundancy"}),": Multiple systems for critical functions"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Monitoring"}),": Continuous system health assessment"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Validation"}),": Verification of safe operation"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Recovery"}),": Automatic recovery from failures"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"safety-framework-components",children:"Safety Framework Components"}),"\n",(0,s.jsx)(r.h3,{id:"1-creating-safety-monitor-node",children:"1. Creating Safety Monitor Node"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cat > ~/isaac_ros_ws/src/isaac_safety_framework/safety_framework/safety_monitor.py << 'EOF\r\n#!/usr/bin/env python3\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import LaserScan, Imu, BatteryState\r\nfrom geometry_msgs.msg import Twist, PoseStamped\r\nfrom std_msgs.msg import Bool, String, Float32\r\nfrom nav_msgs.msg import Odometry\r\nfrom builtin_interfaces.msg import Duration\r\nimport numpy as np\r\nimport math\r\nfrom enum import Enum\r\nfrom typing import Dict, List, Optional\r\n\r\nclass SafetyLevel(Enum):\r\n    SAFE = 0\r\n    WARNING = 1\r\n    DANGER = 2\r\n    EMERGENCY_STOP = 3\r\n\r\nclass SafetyMonitor(Node):\r\n    def __init__(self):\r\n        super().__init__('safety_monitor')\r\n\r\n        # Safety thresholds\r\n        self.safety_thresholds = {\r\n            'min_distance_obstacle': 0.3,  # meters\r\n            'max_linear_velocity': 0.5,    # m/s\r\n            'max_angular_velocity': 1.0,   # rad/s\r\n            'max_acceleration': 2.0,       # m/s\xb2\r\n            'battery_low_threshold': 20.0, # percentage\r\n            'imu_temperature_threshold': 80.0,  # degrees Celsius\r\n            'max_tilt_angle': 30.0,        # degrees\r\n            'max_operation_time': 3600.0   # seconds (1 hour)\r\n        }\r\n\r\n        # System state tracking\r\n        self.current_velocity = Twist()\r\n        self.previous_velocity = Twist()\r\n        self.previous_time = self.get_clock().now()\r\n        self.battery_level = 100.0\r\n        self.imu_data = None\r\n        self.lidar_data = None\r\n        self.odom_data = None\r\n        self.operation_start_time = self.get_clock().now()\r\n        self.emergency_stop_active = False\r\n\r\n        # Subscribers\r\n        self.lidar_subscription = self.create_subscription(\r\n            LaserScan,\r\n            '/scan',\r\n            self.lidar_callback,\r\n            10\r\n        )\r\n\r\n        self.imu_subscription = self.create_subscription(\r\n            Imu,\r\n            '/imu',\r\n            self.imu_callback,\r\n            10\r\n        )\r\n\r\n        self.battery_subscription = self.create_subscription(\r\n            BatteryState,\r\n            '/battery_state',\r\n            self.battery_callback,\r\n            10\r\n        )\r\n\r\n        self.cmd_vel_subscription = self.create_subscription(\r\n            Twist,\r\n            '/cmd_vel',\r\n            self.cmd_vel_callback,\r\n            10\r\n        )\r\n\r\n        self.odom_subscription = self.create_subscription(\r\n            Odometry,\r\n            '/odom',\r\n            self.odom_callback,\r\n            10\r\n        )\r\n\r\n        # Publishers\r\n        self.safety_status_publisher = self.create_publisher(\r\n            Bool,\r\n            '/safety/safe_to_proceed',\r\n            10\r\n        )\r\n\r\n        self.emergency_stop_publisher = self.create_publisher(\r\n            Bool,\r\n            '/safety/emergency_stop',\r\n            10\r\n        )\r\n\r\n        self.safety_level_publisher = self.create_publisher(\r\n            String,\r\n            '/safety/level',\r\n            10\r\n        )\r\n\r\n        self.safety_report_publisher = self.create_publisher(\r\n            String,\r\n            '/safety/report',\r\n            10\r\n        )\r\n\r\n        # Timer for periodic safety checks\r\n        self.safety_timer = self.create_timer(0.1, self.perform_safety_check)\r\n\r\n        self.get_logger().info('Safety Monitor initialized')\r\n\r\n    def lidar_callback(self, msg):\r\n        \"\"\"Process LiDAR data for obstacle detection\"\"\"\r\n        self.lidar_data = msg\r\n\r\n    def imu_callback(self, msg):\r\n        \"\"\"Process IMU data for orientation and acceleration\"\"\"\r\n        self.imu_data = msg\r\n\r\n    def battery_callback(self, msg):\r\n        \"\"\"Process battery data\"\"\"\r\n        self.battery_level = msg.percentage if msg.percentage is not None else 100.0\r\n\r\n    def cmd_vel_callback(self, msg):\r\n        \"\"\"Process velocity commands for safety checking\"\"\"\r\n        self.previous_velocity = self.current_velocity\r\n        self.current_velocity = msg\r\n        self.previous_time = self.get_clock().now()\r\n\r\n    def odom_callback(self, msg):\r\n        \"\"\"Process odometry data\"\"\"\r\n        self.odom_data = msg\r\n\r\n    def perform_safety_check(self):\r\n        \"\"\"Perform comprehensive safety check\"\"\"\r\n        try:\r\n            # Check all safety conditions\r\n            safety_level, report = self.evaluate_safety_conditions()\r\n\r\n            # Publish safety status\r\n            safe_msg = Bool()\r\n            safe_msg.data = (safety_level == SafetyLevel.SAFE)\r\n            self.safety_status_publisher.publish(safe_msg)\r\n\r\n            # Handle emergency stop\r\n            if safety_level == SafetyLevel.EMERGENCY_STOP:\r\n                self.activate_emergency_stop()\r\n            else:\r\n                self.deactivate_emergency_stop()\r\n\r\n            # Publish safety level\r\n            level_msg = String()\r\n            level_msg.data = safety_level.name\r\n            self.safety_level_publisher.publish(level_msg)\r\n\r\n            # Publish safety report\r\n            report_msg = String()\r\n            report_msg.data = report\r\n            self.safety_report_publisher.publish(report_msg)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error in safety check: {e}')\r\n\r\n    def evaluate_safety_conditions(self) -> tuple:\r\n        \"\"\"Evaluate all safety conditions and return safety level and report\"\"\"\r\n        safety_issues = []\r\n        safety_level = SafetyLevel.SAFE\r\n\r\n        # Check for obstacles\r\n        if self.lidar_data:\r\n            min_distance = min(self.lidar_data.ranges) if self.lidar_data.ranges else float('inf')\r\n            if min_distance < self.safety_thresholds['min_distance_obstacle']:\r\n                safety_issues.append(f\"Obstacle detected at {min_distance:.2f}m (threshold: {self.safety_thresholds['min_distance_obstacle']}m)\")\r\n                safety_level = max(safety_level, SafetyLevel.DANGER)\r\n\r\n        # Check velocity limits\r\n        linear_speed = math.sqrt(\r\n            self.current_velocity.linear.x**2 +\r\n            self.current_velocity.linear.y**2 +\r\n            self.current_velocity.linear.z**2\r\n        )\r\n        if linear_speed > self.safety_thresholds['max_linear_velocity']:\r\n            safety_issues.append(f\"Linear velocity too high: {linear_speed:.2f}m/s (threshold: {self.safety_thresholds['max_linear_velocity']}m/s)\")\r\n            safety_level = max(safety_level, SafetyLevel.WARNING)\r\n\r\n        angular_speed = math.sqrt(\r\n            self.current_velocity.angular.x**2 +\r\n            self.current_velocity.angular.y**2 +\r\n            self.current_velocity.angular.z**2\r\n        )\r\n        if angular_speed > self.safety_thresholds['max_angular_velocity']:\r\n            safety_issues.append(f\"Angular velocity too high: {angular_speed:.2f}rad/s (threshold: {self.safety_thresholds['max_angular_velocity']}rad/s)\")\r\n            safety_level = max(safety_level, SafetyLevel.WARNING)\r\n\r\n        # Check battery level\r\n        if self.battery_level < self.safety_thresholds['battery_low_threshold']:\r\n            safety_issues.append(f\"Battery level low: {self.battery_level:.1f}% (threshold: {self.safety_thresholds['battery_low_threshold']}%)\")\r\n            safety_level = max(safety_level, SafetyLevel.WARNING)\r\n\r\n        # Check IMU data for tilt\r\n        if self.imu_data:\r\n            # Calculate tilt from IMU orientation\r\n            orientation = self.imu_data.orientation\r\n            # Convert quaternion to Euler angles to check tilt\r\n            w, x, y, z = orientation.w, orientation.x, orientation.y, orientation.z\r\n            pitch = math.asin(2.0 * (w * y - z * x))\r\n            roll = math.atan2(2.0 * (w * x + y * z), w * w - x * x - y * y + z * z)\r\n\r\n            tilt_angle = math.degrees(math.sqrt(pitch**2 + roll**2))\r\n            if tilt_angle > self.safety_thresholds['max_tilt_angle']:\r\n                safety_issues.append(f\"Excessive tilt: {tilt_angle:.1f}\xb0 (threshold: {self.safety_thresholds['max_tilt_angle']}\xb0)\")\r\n                safety_level = max(safety_level, SafetyLevel.DANGER)\r\n\r\n        # Check operation time\r\n        current_time = self.get_clock().now()\r\n        operation_duration = (current_time - self.operation_start_time).nanoseconds / 1e9\r\n        if operation_duration > self.safety_thresholds['max_operation_time']:\r\n            safety_issues.append(f\"Operation time exceeded: {operation_duration:.0f}s (threshold: {self.safety_thresholds['max_operation_time']}s)\")\r\n            safety_level = max(safety_level, SafetyLevel.WARNING)\r\n\r\n        # Generate report\r\n        if safety_issues:\r\n            report = f\"Safety Level: {safety_level.name}, Issues: \" + \"; \".join(safety_issues)\r\n        else:\r\n            report = f\"Safety Level: {safety_level.name}, All systems nominal\"\r\n\r\n        return safety_level, report\r\n\r\n    def activate_emergency_stop(self):\r\n        \"\"\"Activate emergency stop\"\"\"\r\n        if not self.emergency_stop_active:\r\n            self.emergency_stop_active = True\r\n            stop_msg = Bool()\r\n            stop_msg.data = True\r\n            self.emergency_stop_publisher.publish(stop_msg)\r\n            self.get_logger().warn('EMERGENCY STOP ACTIVATED')\r\n\r\n    def deactivate_emergency_stop(self):\r\n        \"\"\"Deactivate emergency stop\"\"\"\r\n        if self.emergency_stop_active:\r\n            self.emergency_stop_active = False\r\n            stop_msg = Bool()\r\n            stop_msg.data = False\r\n            self.emergency_stop_publisher.publish(stop_msg)\r\n            self.get_logger().info('Emergency stop deactivated')\r\n\r\n    def get_safety_status(self) -> Dict:\r\n        \"\"\"Get current safety status summary\"\"\"\r\n        safety_level, report = self.evaluate_safety_conditions()\r\n        return {\r\n            'safety_level': safety_level.name,\r\n            'report': report,\r\n            'battery_level': self.battery_level,\r\n            'operation_time': (self.get_clock().now() - self.operation_start_time).nanoseconds / 1e9,\r\n            'emergency_stop_active': self.emergency_stop_active\r\n        }\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    safety_monitor = SafetyMonitor()\r\n\r\n    try:\r\n        rclpy.spin(safety_monitor)\r\n    except KeyboardInterrupt:\r\n        status = safety_monitor.get_safety_status()\r\n        print(f\"Safety Status: {status}\")\r\n    finally:\r\n        safety_monitor.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\nEOF\n"})}),"\n",(0,s.jsx)(r.h3,{id:"2-creating-reliability-monitor-node",children:"2. Creating Reliability Monitor Node"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cat > ~/isaac_ros_ws/src/isaac_safety_framework/safety_framework/reliability_monitor.py << 'EOF\r\n#!/usr/bin/env python3\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import Bool, String, Float32\r\nfrom sensor_msgs.msg import Image, LaserScan, Imu\r\nfrom geometry_msgs.msg import Twist\r\nfrom builtin_interfaces.msg import Time\r\nimport time\r\nfrom collections import deque, defaultdict\r\nfrom typing import Dict, List\r\n\r\nclass ReliabilityMonitor(Node):\r\n    def __init__(self):\r\n        super().__init__('reliability_monitor')\r\n\r\n        # Reliability tracking\r\n        self.message_counts = defaultdict(int)\r\n        self.message_intervals = defaultdict(deque)\r\n        self.message_timeliness = defaultdict(deque)\r\n        self.failure_counts = defaultdict(int)\r\n        self.uptime_start = time.time()\r\n        self.reliability_scores = defaultdict(float)\r\n\r\n        # Topic reliability thresholds\r\n        self.reliability_thresholds = {\r\n            'min_frequency': 5.0,      # Hz\r\n            'max_message_age': 1.0,    # seconds\r\n            'max_failure_rate': 0.1    # 10% failure rate\r\n        }\r\n\r\n        # Subscribers for key topics\r\n        self.topic_subscribers = {\r\n            '/camera/color/image_raw': self.create_subscription(\r\n                Image, '/camera/color/image_raw',\r\n                self.create_message_callback('/camera/color/image_raw'), 10\r\n            ),\r\n            '/scan': self.create_subscription(\r\n                LaserScan, '/scan',\r\n                self.create_message_callback('/scan'), 10\r\n            ),\r\n            '/imu': self.create_subscription(\r\n                Imu, '/imu',\r\n                self.create_message_callback('/imu'), 10\r\n            ),\r\n            '/cmd_vel': self.create_subscription(\r\n                Twist, '/cmd_vel',\r\n                self.create_message_callback('/cmd_vel'), 10\r\n            )\r\n        }\r\n\r\n        # Publishers for reliability metrics\r\n        self.reliability_publisher = self.create_publisher(\r\n            Float32,\r\n            '/reliability/score',\r\n            10\r\n        )\r\n\r\n        self.reliability_status_publisher = self.create_publisher(\r\n            String,\r\n            '/reliability/status',\r\n            10\r\n        )\r\n\r\n        # Timer for periodic reliability assessment\r\n        self.assessment_timer = self.create_timer(5.0, self.assess_reliability)\r\n\r\n        self.get_logger().info('Reliability Monitor initialized')\r\n\r\n    def create_message_callback(self, topic_name):\r\n        \"\"\"Create a callback function for a specific topic\"\"\"\r\n        def callback(msg):\r\n            current_time = self.get_clock().now().nanoseconds / 1e9\r\n            self.message_counts[topic_name] += 1\r\n\r\n            # Calculate message interval\r\n            if topic_name in self.message_intervals:\r\n                if len(self.message_intervals[topic_name]) > 0:\r\n                    last_time = self.message_intervals[topic_name][-1]\r\n                    interval = current_time - last_time\r\n                    self.message_intervals[topic_name].append(current_time)\r\n\r\n                    # Keep only recent intervals (last 10)\r\n                    if len(self.message_intervals[topic_name]) > 10:\r\n                        self.message_intervals[topic_name].popleft()\r\n                else:\r\n                    self.message_intervals[topic_name].append(current_time)\r\n            else:\r\n                self.message_intervals[topic_name] = deque([current_time], maxlen=10)\r\n\r\n            # Check message timeliness (for topics with timestamps)\r\n            if hasattr(msg, 'header') and hasattr(msg.header, 'stamp'):\r\n                msg_time = msg.header.stamp.sec + msg.header.stamp.nanosec / 1e9\r\n                age = current_time - msg_time\r\n                self.message_timeliness[topic_name].append(age)\r\n\r\n                # Keep only recent timeliness data\r\n                if len(self.message_timeliness[topic_name]) > 10:\r\n                    self.message_timeliness[topic_name].popleft()\r\n                else:\r\n                    self.message_timeliness[topic_name] = deque(maxlen=10)\r\n\r\n        return callback\r\n\r\n    def assess_reliability(self):\r\n        \"\"\"Assess reliability of all monitored topics\"\"\"\r\n        try:\r\n            overall_reliability = 0.0\r\n            topic_count = 0\r\n\r\n            reliability_report = []\r\n\r\n            for topic in self.topic_subscribers.keys():\r\n                reliability_score = self.calculate_topic_reliability(topic)\r\n                self.reliability_scores[topic] = reliability_score\r\n                overall_reliability += reliability_score\r\n                topic_count += 1\r\n\r\n                # Add to report\r\n                status = \"HIGH\" if reliability_score >= 0.8 else \"MEDIUM\" if reliability_score >= 0.5 else \"LOW\"\r\n                reliability_report.append(f\"{topic}: {status} ({reliability_score:.2f})\")\r\n\r\n            # Calculate overall reliability\r\n            if topic_count > 0:\r\n                overall_reliability /= topic_count\r\n\r\n            # Publish overall reliability score\r\n            score_msg = Float32()\r\n            score_msg.data = overall_reliability\r\n            self.reliability_publisher.publish(score_msg)\r\n\r\n            # Publish reliability status\r\n            status_msg = String()\r\n            status_msg.data = f\"Overall Reliability: {overall_reliability:.2f}, Topics: {', '.join(reliability_report)}\"\r\n            self.reliability_status_publisher.publish(status_msg)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error in reliability assessment: {e}')\r\n\r\n    def calculate_topic_reliability(self, topic_name) -> float:\r\n        \"\"\"Calculate reliability score for a specific topic\"\"\"\r\n        # Base score\r\n        score = 1.0\r\n\r\n        # Check message frequency\r\n        if topic_name in self.message_intervals and len(self.message_intervals[topic_name]) >= 2:\r\n            intervals = list(self.message_intervals[topic_name])\r\n            if len(intervals) > 1:\r\n                avg_interval = sum(\r\n                    intervals[i] - intervals[i-1] for i in range(1, len(intervals))\r\n                ) / (len(intervals) - 1)\r\n\r\n                if avg_interval > 0:\r\n                    frequency = 1.0 / avg_interval\r\n                    if frequency < self.reliability_thresholds['min_frequency']:\r\n                        # Reduce score based on frequency deficiency\r\n                        score *= (frequency / self.reliability_thresholds['min_frequency'])\r\n                else:\r\n                    score = 0.0  # Invalid interval\r\n\r\n        # Check message timeliness\r\n        if topic_name in self.message_timeliness and len(self.message_timeliness[topic_name]) > 0:\r\n            avg_age = sum(self.message_timeliness[topic_name]) / len(self.message_timeliness[topic_name])\r\n            if avg_age > self.reliability_thresholds['max_message_age']:\r\n                # Reduce score based on message age\r\n                penalty = min(1.0, (avg_age - self.reliability_thresholds['max_message_age']) /\r\n                             self.reliability_thresholds['max_message_age'])\r\n                score *= (1.0 - penalty)\r\n\r\n        # Apply failure rate penalty\r\n        total_messages = self.message_counts.get(topic_name, 1)\r\n        failure_rate = self.failure_counts.get(topic_name, 0) / total_messages\r\n        if failure_rate > self.reliability_thresholds['max_failure_rate']:\r\n            penalty = min(1.0, (failure_rate - self.reliability_thresholds['max_failure_rate']) /\r\n                         (1.0 - self.reliability_thresholds['max_failure_rate']))\r\n            score *= (1.0 - penalty)\r\n\r\n        # Ensure score is between 0 and 1\r\n        return max(0.0, min(1.0, score))\r\n\r\n    def get_reliability_summary(self) -> Dict:\r\n        \"\"\"Get reliability summary\"\"\"\r\n        return {\r\n            'overall_reliability': sum(self.reliability_scores.values()) / len(self.reliability_scores) if self.reliability_scores else 0.0,\r\n            'uptime_seconds': time.time() - self.uptime_start,\r\n            'topic_reliabilities': dict(self.reliability_scores),\r\n            'message_counts': dict(self.message_counts),\r\n            'failure_counts': dict(self.failure_counts)\r\n        }\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    reliability_monitor = ReliabilityMonitor()\r\n\r\n    try:\r\n        rclpy.spin(reliability_monitor)\r\n    except KeyboardInterrupt:\r\n        summary = reliability_monitor.get_reliability_summary()\r\n        print(f\"Reliability Summary: {summary}\")\r\n    finally:\r\n        reliability_monitor.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\nEOF\n"})}),"\n",(0,s.jsx)(r.h2,{id:"fault-detection-and-recovery",children:"Fault Detection and Recovery"}),"\n",(0,s.jsx)(r.h3,{id:"1-creating-fault-detection-system",children:"1. Creating Fault Detection System"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cat > ~/isaac_ros_ws/src/isaac_safety_framework/safety_framework/fault_detector.py << 'EOF\r\n#!/usr/bin/env python3\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image, LaserScan, Imu\r\nfrom std_msgs.msg import Bool, String, Float32\r\nfrom geometry_msgs.msg import Twist\r\nfrom builtin_interfaces.msg import Time\r\nimport numpy as np\r\nfrom enum import Enum\r\nfrom collections import deque, defaultdict\r\nfrom typing import Dict, List, Optional\r\n\r\nclass FaultType(Enum):\r\n    SENSOR_FAILURE = \"sensor_failure\"\r\n    COMMUNICATION_ERROR = \"communication_error\"\r\n    ACTUATOR_FAULT = \"actuator_fault\"\r\n    SOFTWARE_ERROR = \"software_error\"\r\n    ENVIRONMENTAL_HAZARD = \"environmental_hazard\"\r\n\r\nclass FaultSeverity(Enum):\r\n    LOW = 1\r\n    MEDIUM = 2\r\n    HIGH = 3\r\n    CRITICAL = 4\r\n\r\nclass FaultDetector(Node):\r\n    def __init__(self):\r\n        super().__init__('fault_detector')\r\n\r\n        # Fault detection parameters\r\n        self.fault_detection_params = {\r\n            'sensor_variance_threshold': 0.1,\r\n            'sensor_stuck_threshold': 0.01,\r\n            'message_timeout': 2.0,  # seconds\r\n            'imu_drift_threshold': 0.05,\r\n            'lidar_spike_threshold': 5.0  # times the median\r\n        }\r\n\r\n        # Data tracking\r\n        self.sensor_data_history = defaultdict(deque)\r\n        self.last_message_times = defaultdict(Time)\r\n        self.fault_history = deque(maxlen=100)\r\n        self.active_faults = set()\r\n\r\n        # Subscribers\r\n        self.topic_subscribers = {\r\n            '/camera/color/image_raw': self.create_subscription(\r\n                Image, '/camera/color/image_raw',\r\n                self.create_sensor_callback('/camera/color/image_raw'), 10\r\n            ),\r\n            '/scan': self.create_subscription(\r\n                LaserScan, '/scan',\r\n                self.create_sensor_callback('/scan'), 10\r\n            ),\r\n            '/imu': self.create_subscription(\r\n                Imu, '/imu',\r\n                self.create_sensor_callback('/imu'), 10\r\n            )\r\n        }\r\n\r\n        # Publishers\r\n        self.fault_publisher = self.create_publisher(\r\n            String,\r\n            '/fault/detected',\r\n            10\r\n        )\r\n\r\n        self.fault_status_publisher = self.create_publisher(\r\n            Bool,\r\n            '/fault/active',\r\n            10\r\n        )\r\n\r\n        # Timer for periodic fault detection\r\n        self.detection_timer = self.create_timer(1.0, self.detect_faults)\r\n\r\n        self.get_logger().info('Fault Detector initialized')\r\n\r\n    def create_sensor_callback(self, topic_name):\r\n        \"\"\"Create a callback function for sensor data\"\"\"\r\n        def callback(msg):\r\n            current_time = self.get_clock().now()\r\n            self.last_message_times[topic_name] = current_time\r\n\r\n            # Process sensor-specific data\r\n            if topic_name == '/scan':\r\n                # Process LiDAR data\r\n                if hasattr(msg, 'ranges') and msg.ranges:\r\n                    # Store range data for variance analysis\r\n                    data_point = np.mean([r for r in msg.ranges if 0.1 < r < 10.0])  # Filter valid ranges\r\n                    self.sensor_data_history[topic_name].append(data_point)\r\n            elif topic_name == '/imu':\r\n                # Process IMU data\r\n                if hasattr(msg, 'linear_acceleration'):\r\n                    # Store acceleration magnitude\r\n                    acc_mag = np.sqrt(\r\n                        msg.linear_acceleration.x**2 +\r\n                        msg.linear_acceleration.y**2 +\r\n                        msg.linear_acceleration.z**2\r\n                    )\r\n                    self.sensor_data_history[topic_name].append(acc_mag)\r\n            elif topic_name == '/camera/color/image_raw':\r\n                # Process image data (simplified - just track image arrival)\r\n                self.sensor_data_history[topic_name].append(1)  # Just mark that image arrived\r\n\r\n            # Keep history to reasonable size\r\n            if len(self.sensor_data_history[topic_name]) > 50:\r\n                self.sensor_data_history[topic_name].popleft()\r\n\r\n        return callback\r\n\r\n    def detect_faults(self):\r\n        \"\"\"Perform fault detection on all monitored systems\"\"\"\r\n        try:\r\n            detected_faults = []\r\n\r\n            # Check each monitored topic\r\n            for topic, last_time in self.last_message_times.items():\r\n                current_time = self.get_clock().now()\r\n\r\n                # Check for message timeout\r\n                time_diff = (current_time.nanoseconds - last_time.nanoseconds) / 1e9\r\n                if time_diff > self.fault_detection_params['message_timeout']:\r\n                    fault = {\r\n                        'type': FaultType.COMMUNICATION_ERROR,\r\n                        'severity': FaultSeverity.HIGH,\r\n                        'component': topic,\r\n                        'description': f'Message timeout: {time_diff:.2f}s since last message'\r\n                    }\r\n                    detected_faults.append(fault)\r\n\r\n            # Check sensor data patterns\r\n            for topic, data_history in self.sensor_data_history.items():\r\n                if len(data_history) >= 10:  # Need enough data for analysis\r\n                    data_array = np.array(data_history)\r\n\r\n                    # Check for sensor stuck (very low variance)\r\n                    variance = np.var(data_array)\r\n                    if variance < self.fault_detection_params['sensor_stuck_threshold']:\r\n                        fault = {\r\n                            'type': FaultType.SENSOR_FAILURE,\r\n                            'severity': FaultSeverity.MEDIUM,\r\n                            'component': topic,\r\n                            'description': f'Sensor stuck detected (variance: {variance:.6f})'\r\n                        }\r\n                        detected_faults.append(fault)\r\n\r\n                    # Check for high variance (potential sensor noise)\r\n                    if variance > self.fault_detection_params['sensor_variance_threshold']:\r\n                        fault = {\r\n                            'type': FaultType.SENSOR_FAILURE,\r\n                            'severity': FaultSeverity.MEDIUM,\r\n                            'component': topic,\r\n                            'description': f'High sensor variance detected: {variance:.6f}'\r\n                        }\r\n                        detected_faults.append(fault)\r\n\r\n                    # Check for LiDAR specific issues\r\n                    if topic == '/scan' and len(data_array) >= 2:\r\n                        # Check for sudden spikes in range data\r\n                        consecutive_diffs = np.abs(np.diff(data_array))\r\n                        if len(consecutive_diffs) > 0 and np.max(consecutive_diffs) > self.fault_detection_params['lidar_spike_threshold']:\r\n                            fault = {\r\n                                'type': FaultType.SENSOR_FAILURE,\r\n                                'severity': FaultSeverity.MEDIUM,\r\n                                'component': topic,\r\n                                'description': f'LiDAR spike detected: {np.max(consecutive_diffs):.2f}'\r\n                            }\r\n                            detected_faults.append(fault)\r\n\r\n            # Process detected faults\r\n            for fault in detected_faults:\r\n                fault_id = f\"{fault['type'].value}_{fault['component']}\"\r\n\r\n                if fault_id not in self.active_faults:\r\n                    # New fault detected\r\n                    self.active_faults.add(fault_id)\r\n\r\n                    # Publish fault notification\r\n                    fault_msg = String()\r\n                    fault_msg.data = f\"{fault['type'].value}: {fault['description']}\"\r\n                    self.fault_publisher.publish(fault_msg)\r\n\r\n                    self.get_logger().warn(f\"FAULT DETECTED: {fault_msg.data}\")\r\n\r\n                    # Add to history\r\n                    fault['timestamp'] = self.get_clock().now().nanoseconds / 1e9\r\n                    self.fault_history.append(fault)\r\n\r\n            # Update fault status\r\n            status_msg = Bool()\r\n            status_msg.data = len(self.active_faults) > 0\r\n            self.fault_status_publisher.publish(status_msg)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error in fault detection: {e}')\r\n\r\n    def get_fault_summary(self) -> Dict:\r\n        \"\"\"Get fault detection summary\"\"\"\r\n        return {\r\n            'active_faults_count': len(self.active_faults),\r\n            'active_faults': list(self.active_faults),\r\n            'total_faults_detected': len(self.fault_history),\r\n            'recent_faults': list(self.fault_history)[-5:]  # Last 5 faults\r\n        }\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    fault_detector = FaultDetector()\r\n\r\n    try:\r\n        rclpy.spin(fault_detector)\r\n    except KeyboardInterrupt:\r\n        summary = fault_detector.get_fault_summary()\r\n        print(f\"Fault Summary: {summary}\")\r\n    finally:\r\n        fault_detector.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\nEOF\n"})}),"\n",(0,s.jsx)(r.h2,{id:"safety-and-reliability-launch-files",children:"Safety and Reliability Launch Files"}),"\n",(0,s.jsx)(r.h3,{id:"1-creating-safety-framework-package",children:"1. Creating Safety Framework Package"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cd ~/isaac_ros_ws/src\r\nsource /opt/ros/humble/setup.bash\r\n\r\n# Create safety framework package\r\nros2 pkg create --build-type ament_python isaac_safety_framework --dependencies rclpy sensor_msgs geometry_msgs std_msgs message_filters tf2_ros tf2_geometry_msgs nav_msgs vision_msgs builtin_interfaces\n"})}),"\n",(0,s.jsx)(r.h3,{id:"2-creating-setup-files-for-safety-package",children:"2. Creating Setup Files for Safety Package"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cat > ~/isaac_ros_ws/src/isaac_safety_framework/setup.py << 'EOF\r\nfrom setuptools import setup\r\nfrom glob import glob\r\nimport os\r\n\r\npackage_name = 'isaac_safety_framework'\r\n\r\nsetup(\r\n    name=package_name,\r\n    version='0.0.1',\r\n    packages=[package_name],\r\n    data_files=[\r\n        ('share/ament_index/resource_index/packages',\r\n            ['resource/' + package_name]),\r\n        ('share/' + package_name, ['package.xml']),\r\n        # Include launch files\r\n        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),\r\n    ],\r\n    install_requires=['setuptools'],\r\n    zip_safe=True,\r\n    maintainer='Your Name',\r\n    maintainer_email='your.email@example.com',\r\n    description='Safety and reliability framework for Isaac Sim AI-Robot systems',\r\n    license='Apache License 2.0',\r\n    tests_require=['pytest'],\r\n    entry_points={\r\n        'console_scripts': [\r\n            'safety_monitor = isaac_safety_framework.safety_monitor:main',\r\n            'reliability_monitor = isaac_safety_framework.reliability_monitor:main',\r\n            'fault_detector = isaac_safety_framework.fault_detector:main',\r\n        ],\r\n    },\r\n)\r\nEOF\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:'cat > ~/isaac_ros_ws/src/isaac_safety_framework/package.xml << \'EOF\'\r\n<?xml version="1.0"?>\r\n<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>\r\n<package format="3">\r\n  <name>isaac_safety_framework</name>\r\n  <version>0.0.1</version>\r\n  <description>Safety and reliability framework for Isaac Sim AI-Robot systems</description>\r\n  <maintainer email="your.email@example.com">Your Name</maintainer>\r\n  <license>Apache License 2.0</license>\r\n\r\n  <depend>rclpy</depend>\r\n  <depend>sensor_msgs</depend>\r\n  <depend>geometry_msgs</depend>\r\n  <depend>std_msgs</depend>\r\n  <depend>message_filters</depend>\r\n  <depend>tf2_ros</depend>\r\n  <depend>tf2_geometry_msgs</depend>\r\n  <depend>nav_msgs</depend>\r\n  <depend>vision_msgs</depend>\r\n  <depend>builtin_interfaces</depend>\r\n\r\n  <test_depend>ament_copyright</test_depend>\r\n  <test_depend>ament_flake8</test_depend>\r\n  <test_depend>ament_pep257</test_depend>\r\n  <test_depend>python3-pytest</test_depend>\r\n\r\n  <export>\r\n    <build_type>ament_python</build_type>\r\n  </export>\r\n</package>\r\nEOF\n'})}),"\n",(0,s.jsx)(r.h3,{id:"3-creating-safety-framework-launch-file",children:"3. Creating Safety Framework Launch File"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"mkdir -p ~/isaac_ros_ws/src/isaac_safety_framework/launch\r\ncat > ~/isaac_ros_ws/src/isaac_safety_framework/launch/safety_framework.launch.py << 'EOF\r\nimport os\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument, TimerAction\r\nfrom launch.substitutions import LaunchConfiguration\r\nfrom launch_ros.actions import Node\r\nfrom ament_index_python.packages import get_package_share_directory\r\n\r\n\r\ndef generate_launch_description():\r\n    # Launch arguments\r\n    use_sim_time = LaunchConfiguration('use_sim_time', default='true')\r\n    enable_safety_monitoring = LaunchConfiguration('enable_safety_monitoring', default='true')\r\n    enable_reliability_monitoring = LaunchConfiguration('enable_reliability_monitoring', default='true')\r\n    enable_fault_detection = LaunchConfiguration('enable_fault_detection', default='true')\r\n\r\n    # Safety monitor node\r\n    safety_monitor = Node(\r\n        package='isaac_safety_framework',\r\n        executable='safety_monitor',\r\n        name='safety_monitor',\r\n        parameters=[{'use_sim_time': use_sim_time}],\r\n        output='screen',\r\n        condition=lambda context: LaunchConfiguration('enable_safety_monitoring').perform(context) == 'true'\r\n    )\r\n\r\n    # Reliability monitor node\r\n    reliability_monitor = Node(\r\n        package='isaac_safety_framework',\r\n        executable='reliability_monitor',\r\n        name='reliability_monitor',\r\n        parameters=[{'use_sim_time': use_sim_time}],\r\n        output='screen',\r\n        condition=lambda context: LaunchConfiguration('enable_reliability_monitoring').perform(context) == 'true'\r\n    )\r\n\r\n    # Fault detector node\r\n    fault_detector = Node(\r\n        package='isaac_safety_framework',\r\n        executable='fault_detector',\r\n        name='fault_detector',\r\n        parameters=[{'use_sim_time': use_sim_time}],\r\n        output='screen',\r\n        condition=lambda context: LaunchConfiguration('enable_fault_detection').perform(context) == 'true'\r\n    )\r\n\r\n    # Return launch description\r\n    ld = LaunchDescription()\r\n\r\n    # Add launch arguments\r\n    ld.add_action(DeclareLaunchArgument(\r\n        'use_sim_time',\r\n        default_value='true',\r\n        description='Use simulation (Isaac Sim) clock if true'))\r\n\r\n    ld.add_action(DeclareLaunchArgument(\r\n        'enable_safety_monitoring',\r\n        default_value='true',\r\n        description='Enable safety monitoring system'))\r\n\r\n    ld.add_action(DeclareLaunchArgument(\r\n        'enable_reliability_monitoring',\r\n        default_value='true',\r\n        description='Enable reliability monitoring system'))\r\n\r\n    ld.add_action(DeclareLaunchArgument(\r\n        'enable_fault_detection',\r\n        default_value='true',\r\n        description='Enable fault detection system'))\r\n\r\n    # Add nodes with timing delays to ensure proper initialization\r\n    ld.add_action(safety_monitor)\r\n    ld.add_action(TimerAction(\r\n        period=2.0,\r\n        actions=[reliability_monitor]\r\n    ))\r\n    ld.add_action(TimerAction(\r\n        period=3.0,\r\n        actions=[fault_detector]\r\n    ))\r\n\r\n    return ld\r\nEOF\n"})}),"\n",(0,s.jsx)(r.h2,{id:"safety-configuration-and-policies",children:"Safety Configuration and Policies"}),"\n",(0,s.jsx)(r.h3,{id:"1-creating-safety-configuration-file",children:"1. Creating Safety Configuration File"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:'cat > ~/isaac_sim_shared/configs/safety_config.yaml << \'EOF\r\n# Safety Configuration for Isaac Sim AI-Robot Systems\r\n\r\nsafety_monitor:\r\n  # Safety thresholds and limits\r\n  thresholds:\r\n    min_distance_obstacle: 0.3  # meters\r\n    max_linear_velocity: 0.5    # m/s\r\n    max_angular_velocity: 1.0   # rad/s\r\n    max_acceleration: 2.0       # m/s\xb2\r\n    battery_low_threshold: 20.0 # percentage\r\n    imu_temperature_threshold: 80.0  # degrees Celsius\r\n    max_tilt_angle: 30.0        # degrees\r\n    max_operation_time: 3600.0  # seconds (1 hour)\r\n\r\n  # Emergency stop configuration\r\n  emergency_stop:\r\n    enable_emergency_stop: true\r\n    stop_distance_threshold: 0.15  # meters before emergency stop\r\n    timeout_after_stop: 30.0       # seconds to wait after emergency stop\r\n\r\n  # Safety level definitions\r\n  safety_levels:\r\n    safe: 0\r\n    warning: 1\r\n    danger: 2\r\n    emergency_stop: 3\r\n\r\nreliability_monitor:\r\n  # Reliability thresholds\r\n  thresholds:\r\n    min_frequency: 5.0      # Hz\r\n    max_message_age: 1.0    # seconds\r\n    max_failure_rate: 0.1   # 10% failure rate\r\n\r\n  # Reliability assessment parameters\r\n  assessment:\r\n    assessment_interval: 5.0  # seconds\r\n    history_size: 10          # number of recent measurements to consider\r\n    grace_period: 10.0        # seconds after startup before reliability assessment begins\r\n\r\nfault_detector:\r\n  # Fault detection parameters\r\n  parameters:\r\n    sensor_variance_threshold: 0.1\r\n    sensor_stuck_threshold: 0.01\r\n    message_timeout: 2.0      # seconds\r\n    imu_drift_threshold: 0.05\r\n    lidar_spike_threshold: 5.0  # times the median\r\n\r\n  # Fault severity levels\r\n  severity_levels:\r\n    low: 1\r\n    medium: 2\r\n    high: 3\r\n    critical: 4\r\n\r\n  # Fault response actions\r\n  response_actions:\r\n    low: "log_warning"\r\n    medium: "reduce_speed"\r\n    high: "pause_operation"\r\n    critical: "emergency_stop"\r\n\r\n# Overall safety policy\r\nsafety_policy:\r\n  # Priority order for safety actions\r\n  priority_order:\r\n    - "emergency_stop"\r\n    - "reduce_speed"\r\n    - "pause_operation"\r\n    - "log_warning"\r\n\r\n  # Safety mode settings\r\n  safety_modes:\r\n    operational:\r\n      allow_movement: true\r\n      monitoring_level: "full"\r\n    degraded:\r\n      allow_movement: false\r\n      monitoring_level: "full"\r\n    emergency:\r\n      allow_movement: false\r\n      monitoring_level: "full"\r\n      emergency_procedures: ["stop_all_motors", "activate_emergency_lights"]\r\n\r\n  # Recovery procedures\r\n  recovery_procedures:\r\n    timeout: 30.0  # seconds to wait before attempting recovery\r\n    retry_attempts: 3\r\n    reset_on_recovery: true\r\n\r\n# Logging and reporting\r\nlogging:\r\n  enable_detailed_logging: true\r\n  log_level: "INFO"\r\n  log_file: "/workspace/shared_dir/logs/safety_log.txt"\r\n  report_interval: 60.0  # seconds between status reports\r\nEOF\n'})}),"\n",(0,s.jsx)(r.h2,{id:"safety-testing-and-validation",children:"Safety Testing and Validation"}),"\n",(0,s.jsx)(r.h3,{id:"1-creating-safety-test-scripts",children:"1. Creating Safety Test Scripts"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cat > ~/isaac_sim_shared/scripts/safety_tests.py << 'EOF\r\n#!/usr/bin/env python3\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import Bool, String, Float32\r\nfrom sensor_msgs.msg import LaserScan, Imu, BatteryState\r\nfrom geometry_msgs.msg import Twist\r\nimport time\r\nimport threading\r\nfrom typing import Dict, List\r\n\r\nclass SafetyTestSuite(Node):\r\n    def __init__(self):\r\n        super().__init__('safety_test_suite')\r\n\r\n        # Test results\r\n        self.test_results = {}\r\n        self.test_in_progress = False\r\n\r\n        # Publishers for test scenarios\r\n        self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)\r\n        self.lidar_publisher = self.create_publisher(LaserScan, '/scan', 10)\r\n\r\n        # Subscribers for safety system responses\r\n        self.safety_status_subscriber = self.create_subscription(\r\n            Bool, '/safety/safe_to_proceed', self.safety_status_callback, 10\r\n        )\r\n\r\n        self.emergency_stop_subscriber = self.create_subscription(\r\n            Bool, '/safety/emergency_stop', self.emergency_stop_callback, 10\r\n        )\r\n\r\n        self.fault_subscriber = self.create_subscription(\r\n            String, '/fault/detected', self.fault_callback, 10\r\n        )\r\n\r\n        self.get_logger().info('Safety Test Suite initialized')\r\n\r\n    def safety_status_callback(self, msg):\r\n        \"\"\"Track safety status during tests\"\"\"\r\n        self.safety_status = msg.data\r\n\r\n    def emergency_stop_callback(self, msg):\r\n        \"\"\"Track emergency stop status during tests\"\"\"\r\n        self.emergency_stop_activated = msg.data\r\n\r\n    def fault_callback(self, msg):\r\n        \"\"\"Track fault detections during tests\"\"\"\r\n        self.last_fault = msg.data\r\n\r\n    def run_all_tests(self) -> Dict:\r\n        \"\"\"Run all safety tests and return results\"\"\"\r\n        self.get_logger().info('Starting safety test suite...')\r\n\r\n        results = {}\r\n\r\n        # Test 1: Emergency stop functionality\r\n        results['emergency_stop'] = self.test_emergency_stop()\r\n        time.sleep(2)  # Wait between tests\r\n\r\n        # Test 2: Obstacle detection\r\n        results['obstacle_detection'] = self.test_obstacle_detection()\r\n        time.sleep(2)\r\n\r\n        # Test 3: Velocity limiting\r\n        results['velocity_limiting'] = self.test_velocity_limiting()\r\n        time.sleep(2)\r\n\r\n        # Test 4: Fault detection\r\n        results['fault_detection'] = self.test_fault_detection()\r\n        time.sleep(2)\r\n\r\n        self.get_logger().info(f'Safety tests completed: {results}')\r\n        return results\r\n\r\n    def test_emergency_stop(self) -> bool:\r\n        \"\"\"Test emergency stop functionality\"\"\"\r\n        self.get_logger().info('Testing emergency stop...')\r\n\r\n        # Initially should be safe to proceed\r\n        safe_before = getattr(self, 'safety_status', True)\r\n\r\n        # Simulate an emergency situation (obstacle very close)\r\n        # This would normally be done by publishing a LiDAR scan with close obstacles\r\n        # For simulation, we'll test the system's response\r\n\r\n        # Wait for system to respond\r\n        time.sleep(1)\r\n\r\n        # Check if emergency stop was activated\r\n        emergency_activated = getattr(self, 'emergency_stop_activated', False)\r\n\r\n        # Reset for next test\r\n        self.emergency_stop_activated = False\r\n\r\n        result = emergency_activated\r\n        self.get_logger().info(f'Emergency stop test: {\"PASS\" if result else \"FAIL\"}')\r\n        return result\r\n\r\n    def test_obstacle_detection(self) -> bool:\r\n        \"\"\"Test obstacle detection functionality\"\"\"\r\n        self.get_logger().info('Testing obstacle detection...')\r\n\r\n        # Publish a LiDAR scan with an obstacle close by\r\n        scan_msg = LaserScan()\r\n        scan_msg.header.stamp = self.get_clock().now().to_msg()\r\n        scan_msg.header.frame_id = 'lidar_link'\r\n        scan_msg.angle_min = -3.14\r\n        scan_msg.angle_max = 3.14\r\n        scan_msg.angle_increment = 0.01\r\n        scan_msg.time_increment = 0.0\r\n        scan_msg.scan_time = 0.0\r\n        scan_msg.range_min = 0.01\r\n        scan_msg.range_max = 25.0\r\n\r\n        # Create ranges with a close obstacle at 0.2m\r\n        ranges = [25.0] * 628  # 628 points for full 360 degrees\r\n        ranges[314] = 0.2  # Obstacle at 180 degrees (0.2m away)\r\n        scan_msg.ranges = ranges\r\n\r\n        self.lidar_publisher.publish(scan_msg)\r\n\r\n        # Wait for processing\r\n        time.sleep(0.5)\r\n\r\n        # Check if safety system responded appropriately\r\n        # In a real test, we'd check if safe_to_proceed became False\r\n        safe_status = getattr(self, 'safety_status', True)\r\n\r\n        result = not safe_status  # Should be unsafe when obstacle is close\r\n        self.get_logger().info(f'Obstacle detection test: {\"PASS\" if result else \"FAIL\"}')\r\n        return result\r\n\r\n    def test_velocity_limiting(self) -> bool:\r\n        \"\"\"Test velocity limiting functionality\"\"\"\r\n        self.get_logger().info('Testing velocity limiting...')\r\n\r\n        # Publish a high velocity command\r\n        cmd_msg = Twist()\r\n        cmd_msg.linear.x = 2.0  # Exceeds safe limit of 0.5 m/s\r\n        cmd_msg.angular.z = 2.0 # Exceeds safe limit of 1.0 rad/s\r\n\r\n        self.cmd_vel_publisher.publish(cmd_msg)\r\n\r\n        # Wait for processing\r\n        time.sleep(0.5)\r\n\r\n        # Check if system detected the unsafe command\r\n        fault_detected = hasattr(self, 'last_fault') and 'velocity' in getattr(self, 'last_fault', '')\r\n\r\n        result = fault_detected\r\n        self.get_logger().info(f'Velocity limiting test: {\"PASS\" if result else \"FAIL\"}')\r\n        return result\r\n\r\n    def test_fault_detection(self) -> bool:\r\n        \"\"\"Test general fault detection\"\"\"\r\n        self.get_logger().info('Testing fault detection...')\r\n\r\n        # Simulate various fault conditions\r\n        # In practice, this would involve creating specific sensor data patterns\r\n        # that trigger fault detection algorithms\r\n\r\n        # Wait for any fault detection\r\n        time.sleep(2)\r\n\r\n        fault_detected = hasattr(self, 'last_fault') and bool(getattr(self, 'last_fault', ''))\r\n\r\n        result = fault_detected\r\n        self.get_logger().info(f'Fault detection test: {\"PASS\" if result else \"FAIL\"}')\r\n        return result\r\n\r\n    def get_test_summary(self) -> Dict:\r\n        \"\"\"Get summary of all safety tests\"\"\"\r\n        return {\r\n            'timestamp': time.time(),\r\n            'total_tests': len(self.test_results),\r\n            'passed_tests': sum(1 for result in self.test_results.values() if result),\r\n            'failed_tests': sum(1 for result in self.test_results.values() if not result),\r\n            'test_results': self.test_results\r\n        }\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    test_suite = SafetyTestSuite()\r\n\r\n    try:\r\n        results = test_suite.run_all_tests()\r\n        summary = test_suite.get_test_summary()\r\n        print(f\"Safety Test Summary: {summary}\")\r\n    except Exception as e:\r\n        print(f\"Error running safety tests: {e}\")\r\n    finally:\r\n        test_suite.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\nEOF\n"})}),"\n",(0,s.jsx)(r.h2,{id:"safety-documentation-and-procedures",children:"Safety Documentation and Procedures"}),"\n",(0,s.jsx)(r.h3,{id:"1-creating-safety-procedures-document",children:"1. Creating Safety Procedures Document"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cat > ~/isaac_sim_shared/docs/safety_procedures.md << 'EOF\r\n# Safety Procedures for Isaac Sim AI-Robot Systems\r\n\r\n## Overview\r\nThis document outlines the safety procedures for operating AI-robot systems in the Isaac Sim environment. These procedures ensure safe operation during development, testing, and validation phases.\r\n\r\n## Pre-Operation Safety Checks\r\n\r\n### 1. System Verification\r\n- [ ] Verify all safety monitoring systems are active\r\n- [ ] Check that emergency stop functionality is operational\r\n- [ ] Confirm sensor systems are providing valid data\r\n- [ ] Validate communication links are stable\r\n- [ ] Ensure battery levels are adequate (>50%)\r\n\r\n### 2. Environment Setup\r\n- [ ] Verify simulation environment is properly configured\r\n- [ ] Check that safety boundaries are defined\r\n- [ ] Confirm obstacle detection systems are calibrated\r\n- [ ] Verify emergency stop zones are established\r\n\r\n## Operational Safety Procedures\r\n\r\n### 1. Normal Operation\r\n- Monitor safety status continuously\r\n- Watch for fault alerts or warnings\r\n- Maintain communication with the system\r\n- Be prepared to activate emergency stop if needed\r\n\r\n### 2. Emergency Procedures\r\nIf an unsafe condition is detected:\r\n\r\n1. **Immediate Response**:\r\n   - Activate emergency stop if system does not respond automatically\r\n   - Assess the situation and identify the cause\r\n   - Document the incident with timestamps and sensor data\r\n\r\n2. **System Recovery**:\r\n   - Allow system to complete any emergency procedures\r\n   - Verify all systems have stopped safely\r\n   - Identify and resolve the root cause\r\n   - Reset safety systems before resuming operation\r\n\r\n### 3. Incident Reporting\r\nAll safety incidents must be documented:\r\n- Time and date of incident\r\n- Conditions leading to incident\r\n- System response\r\n- Actions taken\r\n- Resolution and recovery steps\r\n\r\n## Safety System Configuration\r\n\r\n### 1. Threshold Settings\r\nThe following thresholds should be verified before operation:\r\n\r\n- **Obstacle Distance**: Minimum 0.3m\r\n- **Velocity Limits**: Linear \u2264 0.5 m/s, Angular \u2264 1.0 rad/s\r\n- **Battery Level**: Minimum 20% before shutdown\r\n- **Tilt Angle**: Maximum 30\xb0 from vertical\r\n\r\n### 2. Emergency Response\r\n- **Immediate Stop**: When obstacle < 0.15m\r\n- **Warning**: When obstacle < 0.5m\r\n- **Speed Reduction**: When approaching boundaries\r\n\r\n## Fault Handling Procedures\r\n\r\n### 1. Sensor Faults\r\nIf a sensor fault is detected:\r\n1. Identify which sensor is affected\r\n2. Determine if the system can continue safely with reduced sensing\r\n3. If not, initiate safe shutdown\r\n4. Document the fault for analysis\r\n\r\n### 2. Communication Faults\r\nIf communication is lost:\r\n1. The system should automatically enter safe mode\r\n2. Attempt to reestablish communication\r\n3. If unsuccessful after timeout, initiate emergency stop\r\n4. Document the communication failure\r\n\r\n### 3. Actuator Faults\r\nIf actuator faults are detected:\r\n1. Stop all motion commands immediately\r\n2. Check for mechanical obstructions\r\n3. Verify power and control signals\r\n4. Initiate safe recovery if possible\r\n\r\n## Training Requirements\r\n\r\n### 1. Operator Training\r\nAll operators must complete:\r\n- Safety system operation training\r\n- Emergency procedure training\r\n- Incident reporting procedures\r\n- System-specific safety protocols\r\n\r\n### 2. Certification\r\n- Operators must be certified before unsupervised operation\r\n- Annual recertification required\r\n- Incident response drills conducted quarterly\r\n\r\n## Maintenance and Testing\r\n\r\n### 1. Regular Testing\r\n- Weekly: Basic safety system functionality test\r\n- Monthly: Full safety system validation\r\n- Quarterly: Emergency procedure drills\r\n\r\n### 2. Preventive Maintenance\r\n- Check sensor calibration monthly\r\n- Verify emergency stop functionality weekly\r\n- Update safety software as needed\r\n- Document all maintenance activities\r\n\r\n## Documentation Requirements\r\n\r\n### 1. Safety Records\r\nMaintain records of:\r\n- All safety system tests\r\n- Incident reports\r\n- Maintenance activities\r\n- Operator certifications\r\n\r\n### 2. System Logs\r\n- Continuous logging of safety-relevant data\r\n- Regular backup of safety logs\r\n- Secure storage of safety records\r\n- Access control for safety data\r\n\r\n## Compliance and Standards\r\n\r\nThis safety framework complies with:\r\n- ISO 10218-1:2011 (Industrial robots - Safety requirements)\r\n- ISO/TS 15066:2016 (Collaborative robots)\r\n- ANSI/RIA R15.06 (Industrial robot safety)\r\n- Local safety regulations and standards\r\n\r\n## Continuous Improvement\r\n\r\n### 1. Safety Reviews\r\n- Monthly safety performance reviews\r\n- Quarterly safety procedure updates\r\n- Annual safety framework assessment\r\n\r\n### 2. Feedback Integration\r\n- Operator feedback incorporation\r\n- Incident analysis integration\r\n- Best practice sharing\r\n- Technology update integration\r\n\r\n## Contact Information\r\n\r\nFor safety-related concerns:\r\n- **Safety Officer**: [Contact Information]\r\n- **Technical Support**: [Contact Information]\r\n- **Emergency Contact**: [Contact Information]\r\nEOF\n"})}),"\n",(0,s.jsx)(r.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,s.jsx)(r.h3,{id:"1-creating-safety-framework-test-script",children:"1. Creating Safety Framework Test Script"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:'cat > ~/test_safety_framework.sh << \'EOF\'\r\n#!/bin/bash\r\n\r\n# Test script for safety and reliability framework\r\n\r\necho "Testing Safety and Reliability Framework..."\r\n\r\n# Source ROS environment\r\nsource /opt/ros/humble/setup.bash\r\nsource ~/isaac_ros_ws/install/setup.bash\r\n\r\n# Check if safety framework package is available\r\necho "Checking safety framework package..."\r\nros2 pkg list | grep safety_framework\r\n\r\nif [ $? -eq 0 ]; then\r\n    echo "\u2713 Safety framework package found"\r\nelse\r\n    echo "\u2717 Safety framework package not found"\r\n    exit 1\r\nfi\r\n\r\n# Check for safety configuration files\r\nif [ -f "/workspace/shared_dir/configs/safety_config.yaml" ]; then\r\n    echo "\u2713 Safety configuration file found"\r\nelse\r\n    echo "\u2717 Safety configuration file not found"\r\n    exit 1\r\nfi\r\n\r\n# Check for safety procedures documentation\r\nif [ -f "/workspace/shared_dir/docs/safety_procedures.md" ]; then\r\n    echo "\u2713 Safety procedures documentation found"\r\nelse\r\n    echo "\u2717 Safety procedures documentation not found"\r\n    exit 1\r\nfi\r\n\r\n# Build the safety framework package\r\necho "Building safety framework package..."\r\ncd ~/isaac_ros_ws\r\ncolcon build --packages-select isaac_safety_framework\r\nsource install/setup.bash\r\n\r\n# Check if launch files exist\r\nif [ -f "/workspace/shared_dir/src/isaac_safety_framework/launch/safety_framework.launch.py" ]; then\r\n    echo "\u2713 Safety framework launch file found"\r\nelse\r\n    echo "\u2717 Safety framework launch file not found"\r\n    exit 1\r\nfi\r\n\r\n# Test Python dependencies\r\npython3 -c "import numpy; import rclpy; print(\'\u2713 Required Python packages available\')" || {\r\n    echo "\u2717 Required Python packages not available"\r\n    echo "Installing required packages..."\r\n    pip3 install numpy\r\n}\r\n\r\necho "Safety and Reliability Framework test completed."\r\necho "To run the safety system, use:"\r\necho "ros2 launch isaac_safety_framework safety_framework.launch.py"\r\nEOF\r\n\r\n# Make executable\r\nchmod +x ~/test_safety_framework.sh\n'})}),"\n",(0,s.jsx)(r.h3,{id:"2-running-safety-framework-test",children:"2. Running Safety Framework Test"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"~/test_safety_framework.sh\n"})}),"\n",(0,s.jsx)(r.h2,{id:"troubleshooting-safety-framework",children:"Troubleshooting Safety Framework"}),"\n",(0,s.jsx)(r.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,s.jsx)(r.h4,{id:"issue-safety-monitor-not-responding-to-emergency-conditions",children:'Issue: "Safety monitor not responding to emergency conditions"'}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Solution"}),": Check sensor data and thresholds"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Verify sensor data is being published\r\nros2 topic echo /scan --field ranges | head -20\r\nros2 topic echo /imu --field orientation | head -10\r\n\r\n# Check safety parameter configuration\r\nros2 param list | grep safety\n"})}),"\n",(0,s.jsx)(r.h4,{id:"issue-high-cpu-usage-from-safety-monitoring-nodes",children:'Issue: "High CPU usage from safety monitoring nodes"'}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Solution"}),": Adjust monitoring frequency"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Check current monitoring frequency\r\nros2 node info /safety_monitor\r\nros2 node info /reliability_monitor\n"})}),"\n",(0,s.jsx)(r.h4,{id:"issue-false-positive-fault-detections",children:'Issue: "False positive fault detections"'}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Solution"}),": Calibrate fault detection thresholds"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Review current sensor data patterns\r\nros2 topic hz /camera/color/image_raw\r\nros2 topic hz /scan\n"})}),"\n",(0,s.jsx)(r.h2,{id:"verification-checklist",children:"Verification Checklist"}),"\n",(0,s.jsxs)(r.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",disabled:!0})," ","Safety monitoring node created and functional"]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",disabled:!0})," ","Reliability assessment system implemented"]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",disabled:!0})," ","Fault detection system created"]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",disabled:!0})," ","Safety configuration files created"]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",disabled:!0})," ","Safety procedures documented"]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",disabled:!0})," ","Launch files created for safety framework"]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",disabled:!0})," ","Safety test suite implemented"]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",disabled:!0})," ","Emergency stop functionality verified"]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",disabled:!0})," ","Test script created and functional"]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",disabled:!0})," ","Troubleshooting guide reviewed"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(r.p,{children:"After implementing the safety and reliability framework:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Test safety systems"})," with Isaac Sim running"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Validate emergency procedures"})," and responses"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Calibrate safety thresholds"})," based on operational requirements"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Create safety assessment tools"})," for students"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"The safety and reliability framework is now configured and ready for Module 3, providing students with tools to ensure safe and reliable AI-robot system operation."})]})}function m(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(f,{...e})}):f(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>l});var t=n(6540);const s={},a=t.createContext(s);function i(e){const r=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);