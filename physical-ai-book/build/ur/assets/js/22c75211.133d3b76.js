"use strict";(globalThis.webpackChunkai_native_textbook_physical_ai_humanoid_robotics=globalThis.webpackChunkai_native_textbook_physical_ai_humanoid_robotics||[]).push([[3774],{8446:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"chapter-2/exercise-4","title":"Exercise 4: Cross-Platform Comparative Analysis","description":"Overview","source":"@site/docs/chapter-2/exercise-4.md","sourceDirName":"chapter-2","slug":"/chapter-2/exercise-4","permalink":"/ur/docs/chapter-2/exercise-4","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapter-2/exercise-4.md","tags":[],"version":"current","sidebarPosition":22,"frontMatter":{"sidebar_position":22},"sidebar":"tutorialSidebar","previous":{"title":"Exercise 3: Advanced Navigation","permalink":"/ur/docs/chapter-2/exercise-3"},"next":{"title":"Physics Simulation Validation Tests","permalink":"/ur/docs/chapter-2/tests"}}');var t=r(4848),s=r(8453);const a={sidebar_position:22},o="Exercise 4: Cross-Platform Comparative Analysis",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Exercise Setup",id:"exercise-setup",level:2},{value:"Required Environments",id:"required-environments",level:3},{value:"Test Scenario Definition",id:"test-scenario-definition",level:3},{value:"Exercise Steps",id:"exercise-steps",level:2},{value:"Step 1: Scenario Implementation on Gazebo",id:"step-1-scenario-implementation-on-gazebo",level:3},{value:"Step 2: Scenario Implementation on Unity",id:"step-2-scenario-implementation-on-unity",level:3},{value:"Step 3: Performance Testing",id:"step-3-performance-testing",level:3},{value:"Step 4: Accuracy Validation",id:"step-4-accuracy-validation",level:3},{value:"Step 5: Analysis and Reporting",id:"step-5-analysis-and-reporting",level:3},{value:"Implementation Tasks",id:"implementation-tasks",level:2},{value:"Task 1: Standardized Test Environment",id:"task-1-standardized-test-environment",level:3},{value:"Task 2: Performance Measurement Framework",id:"task-2-performance-measurement-framework",level:3},{value:"Task 3: Accuracy Validation Framework",id:"task-3-accuracy-validation-framework",level:3},{value:"Task 4: Platform Selection Framework",id:"task-4-platform-selection-framework",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Technical Outcomes",id:"technical-outcomes",level:3},{value:"Learning Outcomes",id:"learning-outcomes",level:3},{value:"Assessment Questions",id:"assessment-questions",level:2},{value:"Advanced Challenges",id:"advanced-challenges",level:2},{value:"Resources",id:"resources",level:2},{value:"Next Steps",id:"next-steps",level:2}];function m(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"exercise-4-cross-platform-comparative-analysis",children:"Exercise 4: Cross-Platform Comparative Analysis"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"This exercise focuses on conducting systematic comparative analysis between Gazebo and Unity simulation platforms. Students will implement equivalent scenarios on both platforms, analyze the differences, and develop recommendations for platform selection based on specific application requirements."}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this exercise, you will be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Implement equivalent simulation scenarios on both Gazebo and Unity"}),"\n",(0,t.jsx)(n.li,{children:"Conduct quantitative comparison of platform performance and capabilities"}),"\n",(0,t.jsx)(n.li,{children:"Analyze the trade-offs between different simulation approaches"}),"\n",(0,t.jsx)(n.li,{children:"Develop evidence-based recommendations for platform selection"}),"\n",(0,t.jsx)(n.li,{children:"Validate consistency between platforms for critical applications"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Completion of all previous exercises (1-3)"}),"\n",(0,t.jsx)(n.li,{children:"Understanding of both Gazebo and Unity simulation environments"}),"\n",(0,t.jsx)(n.li,{children:"Experience with physics simulation and sensor modeling"}),"\n",(0,t.jsx)(n.li,{children:"Basic knowledge of performance measurement and analysis"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"exercise-setup",children:"Exercise Setup"}),"\n",(0,t.jsx)(n.h3,{id:"required-environments",children:"Required Environments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Gazebo Environment"}),": Configured with ROS/ROS2 integration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unity Environment"}),": Configured with robotics packages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Development Tools"}),": Python for Gazebo scripting, C# for Unity"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Measurement Tools"}),": Performance monitoring and data collection utilities"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"test-scenario-definition",children:"Test Scenario Definition"}),"\n",(0,t.jsx)(n.p,{children:"Create a standardized test scenario that can be implemented on both platforms:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Environment"}),": Warehouse-like setting with obstacles and narrow passages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robot"}),": Differential drive robot with LiDAR, depth camera, and IMU"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Task"}),": Navigate through environment while mapping and avoiding obstacles"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Metrics"}),": Performance, accuracy, and resource usage measurements"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"exercise-steps",children:"Exercise Steps"}),"\n",(0,t.jsx)(n.h3,{id:"step-1-scenario-implementation-on-gazebo",children:"Step 1: Scenario Implementation on Gazebo"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Environment Creation"}),": Build warehouse scenario with appropriate objects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robot Configuration"}),": Set up robot with required sensors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Navigation System"}),": Implement basic navigation capabilities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Collection"}),": Set up logging and performance monitoring"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-2-scenario-implementation-on-unity",children:"Step 2: Scenario Implementation on Unity"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Environment Creation"}),": Recreate equivalent warehouse scenario"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robot Configuration"}),": Implement equivalent robot and sensors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Navigation System"}),": Implement equivalent navigation capabilities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Collection"}),": Set up equivalent logging and monitoring"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-3-performance-testing",children:"Step 3: Performance Testing"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Baseline Measurements"}),": Establish performance baselines on both platforms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stress Testing"}),": Test with increased complexity (more objects, robots)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Real-time Validation"}),": Verify real-time performance capabilities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource Monitoring"}),": Track CPU, GPU, and memory usage"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-4-accuracy-validation",children:"Step 4: Accuracy Validation"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Physics Accuracy"}),": Compare physics behavior between platforms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sensor Accuracy"}),": Compare sensor outputs and characteristics"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Navigation Accuracy"}),": Compare navigation performance metrics"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consistency Analysis"}),": Validate behavioral consistency"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-5-analysis-and-reporting",children:"Step 5: Analysis and Reporting"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Quantitative Analysis"}),": Statistical comparison of measurements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Qualitative Assessment"}),": User experience and development workflow"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Trade-off Evaluation"}),": Performance vs. quality vs. development effort"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recommendation Development"}),": Platform selection guidelines"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation-tasks",children:"Implementation Tasks"}),"\n",(0,t.jsx)(n.h3,{id:"task-1-standardized-test-environment",children:"Task 1: Standardized Test Environment"}),"\n",(0,t.jsx)(n.p,{children:"Create equivalent environments in both platforms:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Gazebo Implementation"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- warehouse_scenario.world --\x3e\r\n<sdf version="1.7">\r\n  <world name="warehouse_comparison">\r\n    <physics type="ode">\r\n      <max_step_size>0.001</max_step_size>\r\n      <real_time_factor>1</real_time_factor>\r\n      <real_time_update_rate>1000</real_time_update_rate>\r\n    </physics>\r\n\r\n    \x3c!-- Lighting --\x3e\r\n    <include>\r\n      <uri>model://sun</uri>\r\n    </include>\r\n\r\n    \x3c!-- Ground plane --\x3e\r\n    <include>\r\n      <uri>model://ground_plane</uri>\r\n    </include>\r\n\r\n    \x3c!-- Warehouse structures --\x3e\r\n    <model name="warehouse_walls">\r\n      \x3c!-- Define perimeter walls --\x3e\r\n      <pose>0 0 0 0 0 0</pose>\r\n      <link name="wall_north">\r\n        <pose>0 10 1 0 0 0</pose>\r\n        <collision name="collision">\r\n          <geometry><box><size>20 0.2 2</size></box></geometry>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry><box><size>20 0.2 2</size></box></geometry>\r\n        </visual>\r\n      </link>\r\n      \x3c!-- Additional walls... --\x3e\r\n    </model>\r\n\r\n    \x3c!-- Obstacles --\x3e\r\n    <model name="obstacle_1">\r\n      <pose>2 2 0.5 0 0 0</pose>\r\n      <link name="link">\r\n        <collision name="collision">\r\n          <geometry><box><size>1 1 1</size></box></geometry>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry><box><size>1 1 1</size></box></geometry>\r\n        </visual>\r\n        <inertial>\r\n          <mass>1.0</mass>\r\n          <inertia><ixx>0.1667</ixx><iyy>0.1667</iyy><izz>0.1667</izz></inertia>\r\n        </inertial>\r\n      </link>\r\n    </model>\r\n\r\n    \x3c!-- Robot with sensors --\x3e\r\n    <model name="comparison_robot">\r\n      <pose>0 0 0.1 0 0 0</pose>\r\n      <link name="chassis">\r\n        <collision name="collision">\r\n          <geometry><cylinder><radius>0.3</radius><length>0.2</length></cylinder></geometry>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry><cylinder><radius>0.3</radius><length>0.2</length></cylinder></geometry>\r\n        </visual>\r\n        <inertial>\r\n          <mass>5.0</mass>\r\n          <inertia><ixx>0.2</ixx><iyy>0.2</iyy><izz>0.45</izz></inertia>\r\n        </inertial>\r\n      </link>\r\n\r\n      \x3c!-- LiDAR sensor --\x3e\r\n      <sensor type="ray" name="lidar_360">\r\n        <pose>0 0 0.3 0 0 0</pose>\r\n        <ray>\r\n          <scan>\r\n            <horizontal>\r\n              <samples>720</samples>\r\n              <resolution>1</resolution>\r\n              <min_angle>-3.14159</min_angle>\r\n              <max_angle>3.14159</max_angle>\r\n            </horizontal>\r\n          </scan>\r\n          <range>\r\n            <min>0.1</min>\r\n            <max>10.0</max>\r\n            <resolution>0.01</resolution>\r\n          </range>\r\n        </ray>\r\n      </sensor>\r\n\r\n      \x3c!-- IMU sensor --\x3e\r\n      <sensor type="imu" name="imu_sensor">\r\n        <pose>0 0 0.1 0 0 0</pose>\r\n        <imu>\r\n          <angular_velocity>\r\n            <x><noise type="gaussian"><stddev>0.0017</stddev></noise></x>\r\n            <y><noise type="gaussian"><stddev>0.0017</stddev></noise></y>\r\n            <z><noise type="gaussian"><stddev>0.0017</stddev></noise></z>\r\n          </angular_velocity>\r\n          <linear_acceleration>\r\n            <x><noise type="gaussian"><stddev>0.017</stddev></noise></x>\r\n            <y><noise type="gaussian"><stddev>0.017</stddev></noise></y>\r\n            <z><noise type="gaussian"><stddev>0.017</stddev></noise></z>\r\n          </linear_acceleration>\r\n        </imu>\r\n      </sensor>\r\n    </model>\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Unity Implementation"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\npublic class UnityComparisonEnvironment : MonoBehaviour\r\n{\r\n    [Header("Environment Configuration")]\r\n    public float environmentSize = 20f;\r\n    public int obstacleCount = 10;\r\n\r\n    [Header("Robot Configuration")]\r\n    public GameObject robotPrefab;\r\n    public float robotRadius = 0.3f;\r\n    public float robotHeight = 0.2f;\r\n\r\n    [Header("Sensor Configuration")]\r\n    public int lidarResolution = 360;\r\n    public float lidarRange = 10f;\r\n    public float imuNoiseStdDev = 0.0017f;\r\n\r\n    private List<GameObject> obstacles;\r\n    private GameObject robot;\r\n    private LiDARSimulation lidar;\r\n    private IMUSimulation imu;\r\n\r\n    void Start()\r\n    {\r\n        CreateEnvironment();\r\n        CreateRobot();\r\n        ConfigureSensors();\r\n        SetupDataCollection();\r\n    }\r\n\r\n    void CreateEnvironment()\r\n    {\r\n        // Create ground plane\r\n        GameObject ground = GameObject.CreatePrimitive(PrimitiveType.Plane);\r\n        ground.transform.localScale = new Vector3(environmentSize / 10f, 1, environmentSize / 10f);\r\n        ground.name = "Ground";\r\n\r\n        // Create perimeter walls\r\n        CreateWalls();\r\n\r\n        // Create obstacles\r\n        obstacles = new List<GameObject>();\r\n        for (int i = 0; i < obstacleCount; i++)\r\n        {\r\n            GameObject obstacle = GameObject.CreatePrimitive(PrimitiveType.Cube);\r\n            obstacle.transform.position = GenerateRandomPosition();\r\n            obstacle.transform.localScale = new Vector3(1, 1, 1);\r\n            obstacle.GetComponent<Renderer>().material.color = Color.gray;\r\n\r\n            // Add physics properties\r\n            Rigidbody rb = obstacle.AddComponent<Rigidbody>();\r\n            rb.mass = 1f;\r\n            rb.useGravity = true;\r\n\r\n            obstacles.Add(obstacle);\r\n        }\r\n    }\r\n\r\n    void CreateWalls()\r\n    {\r\n        float wallThickness = 0.2f;\r\n        float wallHeight = 2f;\r\n\r\n        // North wall\r\n        GameObject northWall = GameObject.CreatePrimitive(PrimitiveType.Cube);\r\n        northWall.transform.position = new Vector3(0, wallHeight/2, environmentSize/2);\r\n        northWall.transform.localScale = new Vector3(environmentSize, wallHeight, wallThickness);\r\n        northWall.name = "NorthWall";\r\n\r\n        // South wall\r\n        GameObject southWall = GameObject.CreatePrimitive(PrimitiveType.Cube);\r\n        southWall.transform.position = new Vector3(0, wallHeight/2, -environmentSize/2);\r\n        southWall.transform.localScale = new Vector3(environmentSize, wallHeight, wallThickness);\r\n        southWall.name = "SouthWall";\r\n\r\n        // East wall\r\n        GameObject eastWall = GameObject.CreatePrimitive(PrimitiveType.Cube);\r\n        eastWall.transform.position = new Vector3(environmentSize/2, wallHeight/2, 0);\r\n        eastWall.transform.localScale = new Vector3(wallThickness, wallHeight, environmentSize);\r\n        eastWall.name = "EastWall";\r\n\r\n        // West wall\r\n        GameObject westWall = GameObject.CreatePrimitive(PrimitiveType.Cube);\r\n        westWall.transform.position = new Vector3(-environmentSize/2, wallHeight/2, 0);\r\n        westWall.transform.localScale = new Vector3(wallThickness, wallHeight, environmentSize);\r\n        westWall.name = "WestWall";\r\n    }\r\n\r\n    void CreateRobot()\r\n    {\r\n        robot = GameObject.CreatePrimitive(PrimitiveType.Cylinder);\r\n        robot.transform.position = new Vector3(0, robotHeight/2, 0);\r\n        robot.transform.localScale = new Vector3(robotRadius * 2, robotHeight, robotRadius * 2);\r\n        robot.name = "ComparisonRobot";\r\n\r\n        // Add physics properties\r\n        Rigidbody rb = robot.AddComponent<Rigidbody>();\r\n        rb.mass = 5f;\r\n        rb.useGravity = true;\r\n        rb.constraints = RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ;\r\n\r\n        // Add collision detection\r\n        robot.GetComponent<Collider>().isTrigger = false;\r\n    }\r\n\r\n    void ConfigureSensors()\r\n    {\r\n        // Add LiDAR component\r\n        lidar = robot.AddComponent<LiDARSimulation>();\r\n        lidar.horizontalRays = lidarResolution;\r\n        lidar.maxRange = lidarRange;\r\n        lidar.minRange = 0.1f;\r\n\r\n        // Add IMU component\r\n        imu = robot.AddComponent<IMUSimulation>();\r\n        imu.noiseStdDev = imuNoiseStdDev;\r\n    }\r\n\r\n    void SetupDataCollection()\r\n    {\r\n        // Initialize data collection system\r\n        // This would include performance monitoring, logging, etc.\r\n    }\r\n\r\n    Vector3 GenerateRandomPosition()\r\n    {\r\n        float x = Random.Range(-environmentSize/2 + 2, environmentSize/2 - 2);\r\n        float z = Random.Range(-environmentSize/2 + 2, environmentSize/2 - 2);\r\n        return new Vector3(x, 0.5f, z);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"task-2-performance-measurement-framework",children:"Task 2: Performance Measurement Framework"}),"\n",(0,t.jsx)(n.p,{children:"Create a framework for measuring and comparing performance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# performance_comparison.py\r\nimport time\r\nimport psutil\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom dataclasses import dataclass\r\nfrom typing import Dict, List, Tuple\r\nimport json\r\n\r\n@dataclass\r\nclass PerformanceMetrics:\r\n    \"\"\"Data structure for performance metrics\"\"\"\r\n    timestamp: float\r\n    cpu_percent: float\r\n    memory_percent: float\r\n    memory_used_mb: float\r\n    fps: float\r\n    physics_updates: int\r\n    sensor_readings_per_sec: int\r\n    navigation_updates_per_sec: int\r\n\r\nclass PerformanceComparator:\r\n    def __init__(self):\r\n        self.gazebo_metrics = []\r\n        self.unity_metrics = []\r\n        self.start_time = time.time()\r\n\r\n    def collect_gazebo_metrics(self) -> PerformanceMetrics:\r\n        \"\"\"Collect performance metrics from Gazebo simulation\"\"\"\r\n        current_time = time.time()\r\n\r\n        # System metrics\r\n        cpu_percent = psutil.cpu_percent()\r\n        memory_info = psutil.virtual_memory()\r\n        memory_percent = memory_info.percent\r\n        memory_used_mb = memory_info.used / (1024 * 1024)\r\n\r\n        # Simulated metrics (in real implementation, these would come from Gazebo)\r\n        fps = np.random.normal(60, 5)  # Simulated FPS\r\n        physics_updates = np.random.normal(1000, 50)  # Simulated physics updates/sec\r\n        sensor_readings = np.random.normal(10, 2)  # Simulated sensor readings/sec\r\n        nav_updates = np.random.normal(10, 1)  # Simulated navigation updates/sec\r\n\r\n        return PerformanceMetrics(\r\n            timestamp=current_time - self.start_time,\r\n            cpu_percent=cpu_percent,\r\n            memory_percent=memory_percent,\r\n            memory_used_mb=memory_used_mb,\r\n            fps=fps,\r\n            physics_updates=physics_updates,\r\n            sensor_readings_per_sec=sensor_readings,\r\n            navigation_updates_per_sec=nav_updates\r\n        )\r\n\r\n    def collect_unity_metrics(self) -> PerformanceMetrics:\r\n        \"\"\"Collect performance metrics from Unity simulation\"\"\"\r\n        current_time = time.time()\r\n\r\n        # System metrics\r\n        cpu_percent = psutil.cpu_percent()\r\n        memory_info = psutil.virtual_memory()\r\n        memory_percent = memory_info.percent\r\n        memory_used_mb = memory_info.used / (1024 * 1024)\r\n\r\n        # Simulated metrics (in real implementation, these would come from Unity)\r\n        fps = np.random.normal(45, 8)  # Unity typically has different performance\r\n        physics_updates = np.random.normal(900, 100)  # Simulated physics updates/sec\r\n        sensor_readings = np.random.normal(10, 2)  # Simulated sensor readings/sec\r\n        nav_updates = np.random.normal(10, 1)  # Simulated navigation updates/sec\r\n\r\n        return PerformanceMetrics(\r\n            timestamp=current_time - self.start_time,\r\n            cpu_percent=cpu_percent,\r\n            memory_percent=memory_percent,\r\n            memory_used_mb=memory_used_mb,\r\n            fps=fps,\r\n            physics_updates=physics_updates,\r\n            sensor_readings_per_sec=sensor_readings,\r\n            navigation_updates_per_sec=nav_updates\r\n        )\r\n\r\n    def run_comparison_test(self, duration: float = 60.0):\r\n        \"\"\"Run comparison test for specified duration\"\"\"\r\n        start_time = time.time()\r\n\r\n        while time.time() - start_time < duration:\r\n            # Collect metrics from both platforms\r\n            gazebo_metrics = self.collect_gazebo_metrics()\r\n            unity_metrics = self.collect_unity_metrics()\r\n\r\n            self.gazebo_metrics.append(gazebo_metrics)\r\n            self.unity_metrics.append(unity_metrics)\r\n\r\n            time.sleep(0.1)  # Collect metrics every 100ms\r\n\r\n    def analyze_performance(self) -> Dict:\r\n        \"\"\"Analyze collected performance data\"\"\"\r\n        if not self.gazebo_metrics or not self.unity_metrics:\r\n            return {}\r\n\r\n        # Convert to numpy arrays for analysis\r\n        gazebo_fps = np.array([m.fps for m in self.gazebo_metrics])\r\n        unity_fps = np.array([m.fps for m in self.unity_metrics])\r\n\r\n        gazebo_cpu = np.array([m.cpu_percent for m in self.gazebo_metrics])\r\n        unity_cpu = np.array([m.cpu_percent for m in self.unity_metrics])\r\n\r\n        gazebo_memory = np.array([m.memory_used_mb for m in self.gazebo_metrics])\r\n        unity_memory = np.array([m.memory_used_mb for m in self.unity_metrics])\r\n\r\n        analysis = {\r\n            'gazebo': {\r\n                'fps_mean': float(np.mean(gazebo_fps)),\r\n                'fps_std': float(np.std(gazebo_fps)),\r\n                'cpu_mean': float(np.mean(gazebo_cpu)),\r\n                'memory_mean': float(np.mean(gazebo_memory)),\r\n                'metrics_count': len(gazebo_fps)\r\n            },\r\n            'unity': {\r\n                'fps_mean': float(np.mean(unity_fps)),\r\n                'fps_std': float(np.std(unity_fps)),\r\n                'cpu_mean': float(np.mean(unity_cpu)),\r\n                'memory_mean': float(np.mean(unity_memory)),\r\n                'metrics_count': len(unity_fps)\r\n            },\r\n            'comparison': {\r\n                'fps_ratio': float(np.mean(unity_fps) / np.mean(gazebo_fps)) if np.mean(gazebo_fps) > 0 else 0,\r\n                'cpu_ratio': float(np.mean(unity_cpu) / np.mean(gazebo_cpu)) if np.mean(gazebo_cpu) > 0 else 0,\r\n                'memory_ratio': float(np.mean(unity_memory) / np.mean(gazebo_memory)) if np.mean(gazebo_memory) > 0 else 0\r\n            }\r\n        }\r\n\r\n        return analysis\r\n\r\n    def generate_performance_report(self) -> str:\r\n        \"\"\"Generate a performance comparison report\"\"\"\r\n        analysis = self.analyze_performance()\r\n\r\n        report = f\"\"\"\r\nCross-Platform Performance Comparison Report\r\n===========================================\r\n\r\nTest Duration: {len(self.gazebo_metrics) * 0.1:.1f} seconds\r\nSample Count: {len(self.gazebo_metrics)} for each platform\r\n\r\nGazebo Performance:\r\n- Average FPS: {analysis['gazebo']['fps_mean']:.2f} \xb1 {analysis['gazebo']['fps_std']:.2f}\r\n- Average CPU: {analysis['gazebo']['cpu_mean']:.2f}%\r\n- Average Memory: {analysis['gazebo']['memory_mean']:.2f} MB\r\n\r\nUnity Performance:\r\n- Average FPS: {analysis['unity']['fps_mean']:.2f} \xb1 {analysis['unity']['fps_std']:.2f}\r\n- Average CPU: {analysis['unity']['cpu_mean']:.2f}%\r\n- Average Memory: {analysis['unity']['memory_mean']:.2f} MB\r\n\r\nCross-Platform Comparison:\r\n- FPS Ratio (Unity/Gazebo): {analysis['comparison']['fps_ratio']:.2f}\r\n- CPU Ratio (Unity/Gazebo): {analysis['comparison']['cpu_ratio']:.2f}\r\n- Memory Ratio (Unity/Gazebo): {analysis['comparison']['memory_ratio']:.2f}\r\n\r\n\"\"\"\r\n        return report\r\n\r\n    def plot_performance_comparison(self):\r\n        \"\"\"Create visual comparison plots\"\"\"\r\n        if not self.gazebo_metrics or not self.unity_metrics:\r\n            return\r\n\r\n        time_gazebo = [m.timestamp for m in self.gazebo_metrics]\r\n        fps_gazebo = [m.fps for m in self.gazebo_metrics]\r\n\r\n        time_unity = [m.timestamp for m in self.unity_metrics]\r\n        fps_unity = [m.fps for m in self.unity_metrics]\r\n\r\n        plt.figure(figsize=(15, 10))\r\n\r\n        # FPS comparison\r\n        plt.subplot(2, 2, 1)\r\n        plt.plot(time_gazebo, fps_gazebo, label='Gazebo', alpha=0.7)\r\n        plt.plot(time_unity, fps_unity, label='Unity', alpha=0.7)\r\n        plt.xlabel('Time (s)')\r\n        plt.ylabel('FPS')\r\n        plt.title('Frames Per Second Comparison')\r\n        plt.legend()\r\n        plt.grid(True)\r\n\r\n        # CPU usage\r\n        cpu_gazebo = [m.cpu_percent for m in self.gazebo_metrics]\r\n        cpu_unity = [m.cpu_percent for m in self.unity_metrics]\r\n\r\n        plt.subplot(2, 2, 2)\r\n        plt.plot(time_gazebo, cpu_gazebo, label='Gazebo', alpha=0.7)\r\n        plt.plot(time_unity, cpu_unity, label='Unity', alpha=0.7)\r\n        plt.xlabel('Time (s)')\r\n        plt.ylabel('CPU %')\r\n        plt.title('CPU Usage Comparison')\r\n        plt.legend()\r\n        plt.grid(True)\r\n\r\n        # Memory usage\r\n        mem_gazebo = [m.memory_used_mb for m in self.gazebo_metrics]\r\n        mem_unity = [m.memory_used_mb for m in self.unity_metrics]\r\n\r\n        plt.subplot(2, 2, 3)\r\n        plt.plot(time_gazebo, mem_gazebo, label='Gazebo', alpha=0.7)\r\n        plt.plot(time_unity, mem_unity, label='Unity', alpha=0.7)\r\n        plt.xlabel('Time (s)')\r\n        plt.ylabel('Memory (MB)')\r\n        plt.title('Memory Usage Comparison')\r\n        plt.legend()\r\n        plt.grid(True)\r\n\r\n        # Statistical summary\r\n        plt.subplot(2, 2, 4)\r\n        platforms = ['Gazebo', 'Unity']\r\n        avg_fps = [np.mean(fps_gazebo), np.mean(fps_unity)]\r\n        avg_cpu = [np.mean(cpu_gazebo), np.mean(cpu_unity)]\r\n\r\n        x = np.arange(len(platforms))\r\n        width = 0.35\r\n\r\n        plt.bar(x - width/2, avg_fps, width, label='Avg FPS', alpha=0.8)\r\n        plt.bar(x + width/2, avg_cpu, width, label='Avg CPU %', alpha=0.8)\r\n\r\n        plt.xlabel('Platform')\r\n        plt.ylabel('Value')\r\n        plt.title('Average Performance Metrics')\r\n        plt.xticks(x, platforms)\r\n        plt.legend()\r\n        plt.grid(True, axis='y')\r\n\r\n        plt.tight_layout()\r\n        plt.savefig('performance_comparison.png', dpi=300, bbox_inches='tight')\r\n        plt.show()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"task-3-accuracy-validation-framework",children:"Task 3: Accuracy Validation Framework"}),"\n",(0,t.jsx)(n.p,{children:"Create a framework for validating accuracy consistency:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# accuracy_validation.py\r\nimport numpy as np\r\nfrom scipy.spatial.distance import cdist\r\nfrom typing import Dict, List, Tuple\r\nimport json\r\n\r\nclass AccuracyValidator:\r\n    def __init__(self, tolerance: float = 0.05):  # 5% tolerance\r\n        self.tolerance = tolerance\r\n        self.validation_results = {}\r\n\r\n    def validate_physics_behavior(self, gazebo_data: Dict, unity_data: Dict) -> Dict:\r\n        \"\"\"Validate consistency of physics behavior between platforms\"\"\"\r\n        results = {\r\n            'free_fall_consistency': self._validate_free_fall(gazebo_data, unity_data),\r\n            'collision_response': self._validate_collision(gazebo_data, unity_data),\r\n            'friction_effects': self._validate_friction(gazebo_data, unity_data),\r\n            'overall_consistency': 0.0\r\n        }\r\n\r\n        # Calculate overall consistency score\r\n        scores = [v['score'] for v in results.values() if isinstance(v, dict) and 'score' in v]\r\n        if scores:\r\n            results['overall_consistency'] = np.mean(scores)\r\n\r\n        return results\r\n\r\n    def _validate_free_fall(self, gazebo_data: Dict, unity_data: Dict) -> Dict:\r\n        \"\"\"Validate free fall behavior consistency\"\"\"\r\n        # Extract position data over time\r\n        g_time = np.array(gazebo_data.get('time', []))\r\n        g_pos = np.array(gazebo_data.get('positions', [])).reshape(-1, 3)  # x, y, z\r\n\r\n        u_time = np.array(unity_data.get('time', []))\r\n        u_pos = np.array(unity_data.get('positions', [])).reshape(-1, 3)\r\n\r\n        # Calculate acceleration from position data\r\n        if len(g_pos) > 2 and len(u_pos) > 2:\r\n            # Calculate velocity and acceleration\r\n            g_vel = np.gradient(g_pos, g_time[:, None], axis=0)\r\n            g_acc = np.gradient(g_vel, g_time[:, None], axis=0)\r\n\r\n            u_vel = np.gradient(u_pos, u_time[:, None], axis=0)\r\n            u_acc = np.gradient(u_vel, u_time[:, None], axis=0)\r\n\r\n            # Compare average accelerations\r\n            g_avg_acc = np.mean(np.abs(g_acc), axis=0)\r\n            u_avg_acc = np.mean(np.abs(u_acc), axis=0)\r\n\r\n            # Calculate consistency score\r\n            diff = np.abs(g_avg_acc - u_avg_acc) / np.maximum(g_avg_acc, u_avg_acc)\r\n            consistency = 1.0 - np.mean(diff)\r\n            score = max(0, consistency)  # Ensure non-negative\r\n\r\n            return {\r\n                'score': score,\r\n                'gazebo_acceleration': g_avg_acc.tolist(),\r\n                'unity_acceleration': u_avg_acc.tolist(),\r\n                'max_deviation': float(np.max(diff))\r\n            }\r\n\r\n        return {'score': 0.0, 'error': 'Insufficient data for analysis'}\r\n\r\n    def _validate_collision(self, gazebo_data: Dict, unity_data: Dict) -> Dict:\r\n        \"\"\"Validate collision response consistency\"\"\"\r\n        # Compare collision detection and response\r\n        g_collisions = gazebo_data.get('collisions', [])\r\n        u_collisions = unity_data.get('collisions', [])\r\n\r\n        # Analyze collision timing and response\r\n        if g_collisions and u_collisions:\r\n            g_times = [c['time'] for c in g_collisions]\r\n            u_times = [c['time'] for c in u_collisions]\r\n\r\n            # Calculate timing consistency\r\n            min_len = min(len(g_times), len(u_times))\r\n            time_diffs = []\r\n            for i in range(min_len):\r\n                diff = abs(g_times[i] - u_times[i])\r\n                time_diffs.append(diff)\r\n\r\n            avg_time_diff = np.mean(time_diffs) if time_diffs else float('inf')\r\n            score = max(0, 1 - avg_time_diff)  # Higher differences = lower score\r\n\r\n            return {\r\n                'score': score,\r\n                'collision_count_gazebo': len(g_collisions),\r\n                'collision_count_unity': len(u_collisions),\r\n                'avg_time_difference': float(avg_time_diff) if avg_time_diff != float('inf') else 0\r\n            }\r\n\r\n        return {'score': 0.0, 'error': 'No collision data available'}\r\n\r\n    def _validate_friction(self, gazebo_data: Dict, unity_data: Dict) -> Dict:\r\n        \"\"\"Validate friction effect consistency\"\"\"\r\n        # Compare object motion with friction\r\n        g_velocities = np.array(gazebo_data.get('velocities', []))\r\n        u_velocities = np.array(unity_data.get('velocities', []))\r\n\r\n        if len(g_velocities) > 0 and len(u_velocities) > 0:\r\n            # Calculate velocity decay rates\r\n            g_decay = self._calculate_velocity_decay(g_velocities)\r\n            u_decay = self._calculate_velocity_decay(u_velocities)\r\n\r\n            # Compare decay rates\r\n            decay_diff = abs(g_decay - u_decay) / max(g_decay, u_decay, 1e-10)\r\n            score = max(0, 1 - decay_diff)\r\n\r\n            return {\r\n                'score': score,\r\n                'gazebo_decay_rate': float(g_decay),\r\n                'unity_decay_rate': float(u_decay),\r\n                'decay_difference': float(decay_diff)\r\n            }\r\n\r\n        return {'score': 0.0, 'error': 'No velocity data available'}\r\n\r\n    def _calculate_velocity_decay(self, velocities: np.ndarray) -> float:\r\n        \"\"\"Calculate velocity decay rate from velocity data\"\"\"\r\n        if len(velocities) < 2:\r\n            return 0.0\r\n\r\n        # Calculate the rate of change of velocity magnitude\r\n        vel_magnitudes = np.linalg.norm(velocities, axis=1)\r\n\r\n        # Simple linear regression to find decay rate\r\n        times = np.arange(len(vel_magnitudes))\r\n        if len(times) > 1:\r\n            # Calculate slope of velocity magnitude over time\r\n            coeffs = np.polyfit(times, vel_magnitudes, 1)\r\n            return abs(coeffs[0])  # Return absolute value of slope\r\n        else:\r\n            return 0.0\r\n\r\n    def validate_sensor_data(self, gazebo_sensors: Dict, unity_sensors: Dict) -> Dict:\r\n        \"\"\"Validate consistency of sensor data between platforms\"\"\"\r\n        results = {\r\n            'lidar_consistency': self._validate_lidar_data(gazebo_sensors, unity_sensors),\r\n            'imu_consistency': self._validate_imu_data(gazebo_sensors, unity_sensors),\r\n            'accuracy_score': 0.0\r\n        }\r\n\r\n        # Calculate overall accuracy score\r\n        scores = [v['score'] for v in results.values() if isinstance(v, dict) and 'score' in v]\r\n        if scores:\r\n            results['accuracy_score'] = np.mean(scores)\r\n\r\n        return results\r\n\r\n    def _validate_lidar_data(self, gazebo_sensors: Dict, unity_sensors: Dict) -> Dict:\r\n        \"\"\"Validate LiDAR data consistency\"\"\"\r\n        g_lidar = gazebo_sensors.get('lidar', {})\r\n        u_lidar = unity_sensors.get('lidar', {})\r\n\r\n        g_ranges = np.array(g_lidar.get('ranges', []))\r\n        u_ranges = np.array(u_lidar.get('ranges', []))\r\n\r\n        if len(g_ranges) > 0 and len(u_ranges) > 0 and len(g_ranges) == len(u_ranges):\r\n            # Calculate correlation and mean difference\r\n            correlation = np.corrcoef(g_ranges, u_ranges)[0, 1] if len(g_ranges) > 1 else 0\r\n            mean_diff = np.mean(np.abs(g_ranges - u_ranges))\r\n            max_range = max(np.max(g_ranges), np.max(u_ranges))\r\n\r\n            # Normalize difference\r\n            if max_range > 0:\r\n                norm_diff = mean_diff / max_range\r\n                score = correlation * (1 - norm_diff)  # Combine correlation and accuracy\r\n            else:\r\n                score = 0.0\r\n\r\n            return {\r\n                'score': max(0, score),\r\n                'correlation': float(correlation),\r\n                'mean_difference': float(mean_diff),\r\n                'normalized_difference': float(norm_diff) if max_range > 0 else 0\r\n            }\r\n\r\n        return {'score': 0.0, 'error': 'Insufficient or mismatched LiDAR data'}\r\n\r\n    def _validate_imu_data(self, gazebo_sensors: Dict, unity_sensors: Dict) -> Dict:\r\n        \"\"\"Validate IMU data consistency\"\"\"\r\n        g_imu = gazebo_sensors.get('imu', {})\r\n        u_imu = unity_sensors.get('imu', {})\r\n\r\n        g_accel = np.array(g_imu.get('acceleration', []))\r\n        u_accel = np.array(u_imu.get('acceleration', []))\r\n\r\n        g_gyro = np.array(g_imu.get('gyroscope', []))\r\n        u_gyro = np.array(u_imu.get('gyroscope', []))\r\n\r\n        scores = []\r\n\r\n        # Validate acceleration data\r\n        if g_accel.size > 0 and u_accel.size > 0 and g_accel.shape == u_accel.shape:\r\n            accel_corr = np.corrcoef(g_accel.flatten(), u_accel.flatten())[0, 1] if g_accel.size > 1 else 0\r\n            scores.append(max(0, accel_corr))\r\n\r\n        # Validate gyroscope data\r\n        if g_gyro.size > 0 and u_gyro.size > 0 and g_gyro.shape == u_gyro.shape:\r\n            gyro_corr = np.corrcoef(g_gyro.flatten(), u_gyro.flatten())[0, 1] if g_gyro.size > 1 else 0\r\n            scores.append(max(0, gyro_corr))\r\n\r\n        score = np.mean(scores) if scores else 0.0\r\n\r\n        return {\r\n            'score': float(score),\r\n            'acceleration_correlation': float(accel_corr) if 'accel_corr' in locals() else 0,\r\n            'gyroscope_correlation': float(gyro_corr) if 'gyro_corr' in locals() else 0\r\n        }\r\n\r\n    def generate_accuracy_report(self, physics_results: Dict, sensor_results: Dict) -> str:\r\n        \"\"\"Generate accuracy validation report\"\"\"\r\n        report = f\"\"\"\r\nCross-Platform Accuracy Validation Report\r\n=========================================\r\n\r\nPhysics Behavior Validation:\r\n- Free Fall Consistency: {physics_results.get('free_fall_consistency', {}).get('score', 0):.3f}\r\n- Collision Response: {physics_results.get('collision_response', {}).get('score', 0):.3f}\r\n- Friction Effects: {physics_results.get('friction_effects', {}).get('score', 0):.3f}\r\n- Overall Physics Score: {physics_results.get('overall_consistency', 0):.3f}\r\n\r\nSensor Data Validation:\r\n- LiDAR Consistency: {sensor_results.get('lidar_consistency', {}).get('score', 0):.3f}\r\n- IMU Consistency: {sensor_results.get('imu_consistency', {}).get('score', 0):.3f}\r\n- Overall Sensor Score: {sensor_results.get('accuracy_score', 0):.3f}\r\n\r\nTotal Consistency Score: {(physics_results.get('overall_consistency', 0) + sensor_results.get('accuracy_score', 0)) / 2:.3f}\r\n\r\n\"\"\"\r\n        return report\n"})}),"\n",(0,t.jsx)(n.h3,{id:"task-4-platform-selection-framework",children:"Task 4: Platform Selection Framework"}),"\n",(0,t.jsx)(n.p,{children:"Create a framework for recommending platform selection:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# platform_selection.py\r\nfrom dataclasses import dataclass\r\nfrom typing import Dict, List\r\nimport numpy as np\r\n\r\n@dataclass\r\nclass ApplicationRequirements:\r\n    \"\"\"Data structure for application requirements\"\"\"\r\n    physics_accuracy: float = 0.5  # 0-1, higher = more accurate physics needed\r\n    visual_quality: float = 0.5    # 0-1, higher = better visuals needed\r\n    real_time_performance: float = 0.5  # 0-1, higher = more real-time performance needed\r\n    ros_integration: float = 0.5   # 0-1, higher = more ROS integration needed\r\n    development_time: float = 0.5  # 0-1, higher = less time available for development\r\n    hardware_constraints: float = 0.5  # 0-1, higher = more constrained hardware\r\n    multi_robot_support: float = 0.5   # 0-1, higher = more multi-robot support needed\r\n    user_experience: float = 0.5       # 0-1, higher = better UX needed\r\n\r\nclass PlatformSelector:\r\n    def __init__(self):\r\n        self.gazebo_strengths = {\r\n            'physics_accuracy': 0.9,\r\n            'ros_integration': 0.95,\r\n            'multi_robot_support': 0.85,\r\n            'development_time': 0.7,  # Moderate for robotics experts\r\n            'hardware_constraints': 0.6,  # Moderate resource usage\r\n            'real_time_performance': 0.7,  # Good for robotics workloads\r\n            'visual_quality': 0.4,  # Lower visual quality\r\n            'user_experience': 0.5  # Moderate UX for robotics users\r\n        }\r\n\r\n        self.unity_strengths = {\r\n            'visual_quality': 0.95,\r\n            'user_experience': 0.9,\r\n            'real_time_performance': 0.8,  # Good rendering performance\r\n            'development_time': 0.6,  # Moderate for game developers\r\n            'hardware_constraints': 0.7,  # Higher resource usage\r\n            'physics_accuracy': 0.6,  # Good but not robotics-optimized\r\n            'ros_integration': 0.4,  # Requires plugins\r\n            'multi_robot_support': 0.5  # Moderate with plugins\r\n        }\r\n\r\n    def calculate_platform_scores(self, requirements: ApplicationRequirements) -> Dict[str, float]:\r\n        \"\"\"Calculate platform scores based on requirements\"\"\"\r\n        gazebo_score = (\r\n            requirements.physics_accuracy * self.gazebo_strengths['physics_accuracy'] +\r\n            requirements.ros_integration * self.gazebo_strengths['ros_integration'] +\r\n            requirements.multi_robot_support * self.gazebo_strengths['multi_robot_support'] +\r\n            requirements.development_time * self.gazebo_strengths['development_time'] +\r\n            (1 - requirements.hardware_constraints) * self.gazebo_strengths['hardware_constraints'] +\r\n            requirements.real_time_performance * self.gazebo_strengths['real_time_performance'] +\r\n            requirements.visual_quality * self.gazebo_strengths['visual_quality'] +\r\n            requirements.user_experience * self.gazebo_strengths['user_experience']\r\n        ) / 8\r\n\r\n        unity_score = (\r\n            requirements.physics_accuracy * self.unity_strengths['physics_accuracy'] +\r\n            requirements.ros_integration * self.unity_strengths['ros_integration'] +\r\n            requirements.multi_robot_support * self.unity_strengths['multi_robot_support'] +\r\n            requirements.development_time * self.unity_strengths['development_time'] +\r\n            (1 - requirements.hardware_constraints) * self.unity_strengths['hardware_constraints'] +\r\n            requirements.real_time_performance * self.unity_strengths['real_time_performance'] +\r\n            requirements.visual_quality * self.unity_strengths['visual_quality'] +\r\n            requirements.user_experience * self.unity_strengths['user_experience']\r\n        ) / 8\r\n\r\n        return {\r\n            'gazebo': gazebo_score,\r\n            'unity': unity_score,\r\n            'difference': unity_score - gazebo_score\r\n        }\r\n\r\n    def recommend_platform(self, requirements: ApplicationRequirements) -> str:\r\n        \"\"\"Recommend the best platform based on requirements\"\"\"\r\n        scores = self.calculate_platform_scores(requirements)\r\n\r\n        if abs(scores['difference']) < 0.05:  # Less than 5% difference\r\n            return \"BOTH - Both platforms are suitable; consider hybrid approach or team expertise\"\r\n        elif scores['gazebo'] > scores['unity']:\r\n            return \"GAZEBO - Recommended for robotics-focused applications with high physics accuracy and ROS integration needs\"\r\n        else:\r\n            return \"UNITY - Recommended for applications requiring high visual quality and user experience\"\r\n\r\n    def generate_recommendation_report(self, requirements: ApplicationRequirements) -> str:\r\n        \"\"\"Generate detailed recommendation report\"\"\"\r\n        scores = self.calculate_platform_scores(requirements)\r\n        recommendation = self.recommend_platform(requirements)\r\n\r\n        report = f\"\"\"\r\nPlatform Selection Recommendation Report\r\n========================================\r\n\r\nApplication Requirements:\r\n- Physics Accuracy Need: {requirements.physics_accuracy:.2f}\r\n- Visual Quality Need: {requirements.visual_quality:.2f}\r\n- Real-time Performance Need: {requirements.real_time_performance:.2f}\r\n- ROS Integration Need: {requirements.ros_integration:.2f}\r\n- Development Time Constraint: {requirements.development_time:.2f}\r\n- Hardware Constraints: {requirements.hardware_constraints:.2f}\r\n- Multi-Robot Support Need: {requirements.multi_robot_support:.2f}\r\n- User Experience Need: {requirements.user_experience:.2f}\r\n\r\nPlatform Scores:\r\n- Gazebo Score: {scores['gazebo']:.3f}\r\n- Unity Score: {scores['unity']:.3f}\r\n- Score Difference: {scores['difference']:.3f}\r\n\r\nRecommendation: {recommendation}\r\n\r\n\"\"\"\r\n        return report\r\n\r\ndef create_application_profiles():\r\n    \"\"\"Create common application profiles for quick selection\"\"\"\r\n    profiles = {\r\n        'research_robotics': ApplicationRequirements(\r\n            physics_accuracy=0.9,\r\n            ros_integration=0.9,\r\n            multi_robot_support=0.8,\r\n            visual_quality=0.4,\r\n            user_experience=0.5\r\n        ),\r\n        'training_simulator': ApplicationRequirements(\r\n            visual_quality=0.9,\r\n            user_experience=0.9,\r\n            real_time_performance=0.7,\r\n            physics_accuracy=0.6\r\n        ),\r\n        'industrial_automation': ApplicationRequirements(\r\n            physics_accuracy=0.8,\r\n            ros_integration=0.8,\r\n            multi_robot_support=0.9,\r\n            real_time_performance=0.8\r\n        ),\r\n        'consumer_app': ApplicationRequirements(\r\n            visual_quality=0.9,\r\n            user_experience=0.9,\r\n            development_time=0.8,\r\n            physics_accuracy=0.5\r\n        )\r\n    }\r\n    return profiles\n"})}),"\n",(0,t.jsx)(n.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,t.jsx)(n.h3,{id:"technical-outcomes",children:"Technical Outcomes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Quantitative comparison data between platforms"}),"\n",(0,t.jsx)(n.li,{children:"Performance and accuracy validation results"}),"\n",(0,t.jsx)(n.li,{children:"Evidence-based platform selection recommendations"}),"\n",(0,t.jsx)(n.li,{children:"Understanding of trade-offs between different approaches"}),"\n",(0,t.jsx)(n.li,{children:"Documentation of best practices for each platform"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Ability to conduct systematic platform comparisons"}),"\n",(0,t.jsx)(n.li,{children:"Skills in performance measurement and analysis"}),"\n",(0,t.jsx)(n.li,{children:"Understanding of platform strengths and limitations"}),"\n",(0,t.jsx)(n.li,{children:"Knowledge of validation techniques for simulation consistency"}),"\n",(0,t.jsx)(n.li,{children:"Experience with recommendation frameworks for technology selection"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Analysis"}),": Based on your comparison, what are the key factors that determine platform selection for robotics simulation?"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem-Solving"}),": How would you design a validation test to ensure that navigation algorithms perform consistently across platforms?"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Application"}),": In what scenarios would a hybrid approach using both platforms be most beneficial?"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Evaluation"}),": What are the main challenges in maintaining consistency between different simulation platforms?"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"advanced-challenges",children:"Advanced Challenges"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Automated Testing"}),": Implement automated cross-platform validation that runs regularly"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Scalability Analysis"}),": Test how each platform scales with increasing complexity"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Hybrid Architecture"}),": Design a system that leverages strengths of both platforms"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Real-world Validation"}),": Compare simulation results with physical robot experiments"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/2103.14586",children:"Gazebo vs Unity Comparison Studies"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9123456",children:"Robotics Simulation Best Practices"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html",children:"Performance Optimization Techniques"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://gazebosim.org/docs/latest/ros_and_unity/",children:"Cross-Platform Development Guidelines"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsx)(n.p,{children:"After completing this comparative analysis exercise, you will have a comprehensive understanding of both simulation platforms and be able to make informed decisions about platform selection for future robotics projects. Consider applying these comparison techniques to other tools and technologies in your robotics workflow."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var i=r(6540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);