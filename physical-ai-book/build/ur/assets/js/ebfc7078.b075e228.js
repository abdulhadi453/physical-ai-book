"use strict";(globalThis.webpackChunkai_native_textbook_physical_ai_humanoid_robotics=globalThis.webpackChunkai_native_textbook_physical_ai_humanoid_robotics||[]).push([[4027],{2853:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"chapter-4/lesson-4","title":"Lesson 4.1.4: ROS 2 Action Execution","description":"Overview","source":"@site/docs/chapter-4/lesson-4.md","sourceDirName":"chapter-4","slug":"/chapter-4/lesson-4","permalink":"/ur/docs/chapter-4/lesson-4","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapter-4/lesson-4.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 4.1.3: Visual Perception Integration","permalink":"/ur/docs/chapter-4/lesson-3"},"next":{"title":"Lesson 4.1.5: VLA System Integration","permalink":"/ur/docs/chapter-4/lesson-5"}}');var i=t(4848),o=t(8453);const a={},s="Lesson 4.1.4: ROS 2 Action Execution",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Action Execution Architecture",id:"action-execution-architecture",level:2},{value:"Implementation Steps",id:"implementation-steps",level:2},{value:"Step 1: Set Up ROS 2 Action Definitions",id:"step-1-set-up-ros-2-action-definitions",level:3},{value:"Step 2: Create Action Execution Manager",id:"step-2-create-action-execution-manager",level:3},{value:"Step 3: Create Action Server Implementations",id:"step-3-create-action-server-implementations",level:3},{value:"Step 4: Integrate with VLA System",id:"step-4-integrate-with-vla-system",level:3},{value:"Practical Exercise",id:"practical-exercise",level:2},{value:"Exercise 4.1: Action Execution Implementation",id:"exercise-41-action-execution-implementation",level:3},{value:"Key Concepts",id:"key-concepts",level:2},{value:"ROS 2 Action Interfaces",id:"ros-2-action-interfaces",level:3},{value:"Execution State Management",id:"execution-state-management",level:3},{value:"Integration with Simulation",id:"integration-with-simulation",level:3},{value:"Common Challenges and Solutions",id:"common-challenges-and-solutions",level:2},{value:"Challenge 1: Action Timeout Management",id:"challenge-1-action-timeout-management",level:3},{value:"Challenge 2: State Synchronization",id:"challenge-2-state-synchronization",level:3},{value:"Challenge 3: Error Recovery",id:"challenge-3-error-recovery",level:3},{value:"Assessment Questions",id:"assessment-questions",level:2},{value:"Summary",id:"summary",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"lesson-414-ros-2-action-execution",children:"Lesson 4.1.4: ROS 2 Action Execution"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Welcome to Lesson 4 of the Vision-Language-Action (VLA) Systems module! In this lesson, you will implement the ROS 2 action execution component of the VLA system. This component is responsible for executing the action sequences generated by the cognitive planning system using ROS 2 action servers and clients. The action execution system bridges the gap between high-level planning and low-level robot control, translating abstract action steps into concrete robotic behaviors."}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Implement ROS 2 action servers for navigation and manipulation tasks"}),"\n",(0,i.jsx)(n.li,{children:"Create action clients that execute action sequences from the cognitive planner"}),"\n",(0,i.jsx)(n.li,{children:"Monitor execution state and provide feedback to the VLA system"}),"\n",(0,i.jsx)(n.li,{children:"Handle action failures and implement recovery procedures"}),"\n",(0,i.jsx)(n.li,{children:"Integrate with NVIDIA Isaac Sim for simulation-based execution"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(n.p,{children:"Before starting this lesson, ensure you have:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Completed Lesson 1-3 (Voice Processing, Cognitive Planning, Visual Perception)"}),"\n",(0,i.jsx)(n.li,{children:"Set up ROS 2 Humble Hawksbill with required packages"}),"\n",(0,i.jsx)(n.li,{children:"Familiarized yourself with the VLA system architecture"}),"\n",(0,i.jsx)(n.li,{children:"Understood basic concepts of ROS 2 actions, services, and topics"}),"\n",(0,i.jsx)(n.li,{children:"Set up NVIDIA Isaac Sim environment for testing"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"action-execution-architecture",children:"Action Execution Architecture"}),"\n",(0,i.jsx)(n.p,{children:"The action execution component follows this architecture:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Action Sequence \u2192 ROS 2 Action Client \u2192 Robot Control \u2192 Execution Feedback \u2192 VLA System\n"})}),"\n",(0,i.jsx)(n.p,{children:"Key considerations include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Using ROS 2 action interfaces for long-running operations"}),"\n",(0,i.jsx)(n.li,{children:"Implementing proper feedback and status reporting"}),"\n",(0,i.jsx)(n.li,{children:"Handling action timeouts and failures gracefully"}),"\n",(0,i.jsx)(n.li,{children:"Ensuring safety constraints during execution"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,i.jsx)(n.h3,{id:"step-1-set-up-ros-2-action-definitions",children:"Step 1: Set Up ROS 2 Action Definitions"}),"\n",(0,i.jsx)(n.p,{children:"First, let's create the action definition files that will be used for communication between the VLA system and robot controllers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/vla/ros2/action_interfaces.py\r\n\r\nimport rclpy\r\nfrom rclpy.action import ActionClient, ActionServer\r\nfrom rclpy.node import Node\r\nfrom typing import Dict, Any, Optional, Callable\r\nimport time\r\nimport logging\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass NavigationActionInterface:\r\n    """\r\n    Interface for navigation actions using ROS 2 action servers.\r\n    """\r\n\r\n    def __init__(self, node: Node):\r\n        """\r\n        Initialize navigation action interface.\r\n\r\n        Args:\r\n            node: ROS 2 node to use for action communication\r\n        """\r\n        self.node = node\r\n\r\n        # Import navigation action types (these would be generated from .action files)\r\n        try:\r\n            from nav2_msgs.action import NavigateToPose\r\n            self.NavigateToPose = NavigateToPose\r\n        except ImportError:\r\n            logger.warning("nav2_msgs not available, using mock navigation")\r\n            self.NavigateToPose = None\r\n\r\n        # Create action client for navigation\r\n        self.nav_to_pose_client = None\r\n        if self.NavigateToPose:\r\n            self.nav_to_pose_client = ActionClient(\r\n                node,\r\n                self.NavigateToPose,\r\n                \'navigate_to_pose\'\r\n            )\r\n\r\n    def navigate_to_pose(self,\r\n                        x: float,\r\n                        y: float,\r\n                        z: float,\r\n                        timeout: float = 30.0) -> bool:\r\n        """\r\n        Navigate to a specific pose using ROS 2 navigation action.\r\n\r\n        Args:\r\n            x: Target X coordinate\r\n            y: Target Y coordinate\r\n            z: Target Z coordinate (height)\r\n            timeout: Maximum time to wait for completion\r\n\r\n        Returns:\r\n            True if navigation completed successfully, False otherwise\r\n        """\r\n        if not self.nav_to_pose_client:\r\n            logger.warning("Navigation action client not available, simulating navigation")\r\n            # Simulate navigation for testing\r\n            time.sleep(min(2.0, timeout))\r\n            return True\r\n\r\n        try:\r\n            # Wait for action server\r\n            if not self.nav_to_pose_client.wait_for_server(timeout_sec=5.0):\r\n                logger.error("Navigation action server not available")\r\n                return False\r\n\r\n            # Create goal message\r\n            goal_msg = self.NavigateToPose.Goal()\r\n            goal_msg.pose.header.frame_id = \'map\'\r\n            goal_msg.pose.header.stamp = self.node.get_clock().now().to_msg()\r\n\r\n            goal_msg.pose.pose.position.x = float(x)\r\n            goal_msg.pose.pose.position.y = float(y)\r\n            goal_msg.pose.pose.position.z = float(z)\r\n            # Set orientation to face forward (no rotation)\r\n            goal_msg.pose.pose.orientation.w = 1.0\r\n\r\n            # Send goal\r\n            goal_future = self.nav_to_pose_client.send_goal_async(goal_msg)\r\n\r\n            # Wait for result with timeout\r\n            start_time = time.time()\r\n            while time.time() - start_time < timeout:\r\n                if goal_future.done():\r\n                    goal_handle = goal_future.result()\r\n                    if goal_handle.accepted:\r\n                        logger.info("Navigation goal accepted, waiting for result...")\r\n\r\n                        # Wait for result\r\n                        result_future = goal_handle.get_result_async()\r\n\r\n                        # Wait for result with remaining time\r\n                        remaining_time = timeout - (time.time() - start_time)\r\n                        if remaining_time > 0:\r\n                            # In a real implementation, we\'d properly wait for the result\r\n                            # For simulation purposes, we\'ll return success after a brief delay\r\n                            time.sleep(min(1.0, remaining_time))\r\n                            return True\r\n                    else:\r\n                        logger.error("Navigation goal was rejected")\r\n                        return False\r\n\r\n                time.sleep(0.1)  # Small delay to prevent busy waiting\r\n\r\n            logger.warning("Navigation timeout reached")\r\n            return False\r\n\r\n        except Exception as e:\r\n            logger.error(f"Navigation failed: {e}")\r\n            return False\r\n\r\nclass ManipulationActionInterface:\r\n    """\r\n    Interface for manipulation actions using ROS 2 action servers.\r\n    """\r\n\r\n    def __init__(self, node: Node):\r\n        """\r\n        Initialize manipulation action interface.\r\n\r\n        Args:\r\n            node: ROS 2 node to use for action communication\r\n        """\r\n        self.node = node\r\n\r\n        # Mock action types for manipulation (in real system, these would be custom action types)\r\n        self.grasp_action_client = None\r\n        self.place_action_client = None\r\n\r\n        # For now, we\'ll use a simple interface - in a real system, you\'d have custom action types\r\n        logger.info("Manipulation action interface initialized (mock implementation)")\r\n\r\n    def grasp_object(self,\r\n                    object_id: str,\r\n                    timeout: float = 10.0) -> bool:\r\n        """\r\n        Execute grasp action for a specific object.\r\n\r\n        Args:\r\n            object_id: ID of the object to grasp\r\n            timeout: Maximum time to wait for completion\r\n\r\n        Returns:\r\n            True if grasp completed successfully, False otherwise\r\n        """\r\n        try:\r\n            logger.info(f"Attempting to grasp object: {object_id}")\r\n\r\n            # In a real implementation, this would send a grasp action goal\r\n            # For simulation, we\'ll simulate the grasp process\r\n            time.sleep(min(2.0, timeout))\r\n\r\n            # Simulate grasp success/failure based on object properties\r\n            # In a real system, you\'d check grasp success with sensors\r\n            logger.info(f"Grasp completed for object: {object_id}")\r\n            return True\r\n\r\n        except Exception as e:\r\n            logger.error(f"Grasp action failed: {e}")\r\n            return False\r\n\r\n    def release_object(self, timeout: float = 5.0) -> bool:\r\n        """\r\n        Execute release action to drop currently held object.\r\n\r\n        Args:\r\n            timeout: Maximum time to wait for completion\r\n\r\n        Returns:\r\n            True if release completed successfully, False otherwise\r\n        """\r\n        try:\r\n            logger.info("Releasing currently held object")\r\n\r\n            # In a real implementation, this would send a release action goal\r\n            # For simulation, we\'ll simulate the release process\r\n            time.sleep(min(1.0, timeout))\r\n\r\n            logger.info("Object release completed")\r\n            return True\r\n\r\n        except Exception as e:\r\n            logger.error(f"Release action failed: {e}")\r\n            return False\r\n\r\nclass ActionExecutorNode(Node):\r\n    """\r\n    ROS 2 node that executes action sequences generated by the cognitive planner.\r\n    """\r\n\r\n    def __init__(self):\r\n        """\r\n        Initialize action executor node.\r\n        """\r\n        super().__init__(\'vla_action_executor\')\r\n\r\n        # Initialize action interfaces\r\n        self.navigation_interface = NavigationActionInterface(self)\r\n        self.manipulation_interface = ManipulationActionInterface(self)\r\n\r\n        # Execution state tracking\r\n        self.current_execution_id = None\r\n        self.is_executing = False\r\n        self.execution_callback = None\r\n\r\n        logger.info("VLA Action Executor node initialized")\r\n\r\n    def execute_action_sequence(self,\r\n                              action_sequence: list,\r\n                              callback: Optional[Callable] = None) -> str:\r\n        """\r\n        Execute a sequence of actions generated by the cognitive planner.\r\n\r\n        Args:\r\n            action_sequence: List of action steps to execute\r\n            callback: Optional callback function for execution updates\r\n\r\n        Returns:\r\n            Execution ID for tracking\r\n        """\r\n        execution_id = f"exec_{int(time.time())}"\r\n        self.current_execution_id = execution_id\r\n        self.execution_callback = callback\r\n        self.is_executing = True\r\n\r\n        logger.info(f"Starting execution {execution_id} with {len(action_sequence)} actions")\r\n\r\n        try:\r\n            success_count = 0\r\n            total_actions = len(action_sequence)\r\n\r\n            for i, action in enumerate(action_sequence):\r\n                if not self.is_executing:\r\n                    logger.info("Execution stopped by user")\r\n                    break\r\n\r\n                # Report progress\r\n                if self.execution_callback:\r\n                    self.execution_callback({\r\n                        \'execution_id\': execution_id,\r\n                        \'current_action\': i + 1,\r\n                        \'total_actions\': total_actions,\r\n                        \'status\': \'executing\',\r\n                        \'progress\': (i + 1) / total_actions\r\n                    })\r\n\r\n                # Execute the action\r\n                action_success = self._execute_single_action(action)\r\n\r\n                if action_success:\r\n                    success_count += 1\r\n                    logger.info(f"Action {i+1}/{total_actions} completed successfully")\r\n                else:\r\n                    logger.error(f"Action {i+1}/{total_actions} failed")\r\n                    # Optionally stop execution on failure, or continue with next action\r\n                    # For now, we\'ll continue to next action\r\n                    continue\r\n\r\n            # Report final status\r\n            if self.execution_callback:\r\n                self.execution_callback({\r\n                    \'execution_id\': execution_id,\r\n                    \'current_action\': total_actions,\r\n                    \'total_actions\': total_actions,\r\n                    \'status\': \'completed\',\r\n                    \'progress\': 1.0,\r\n                    \'success_count\': success_count,\r\n                    \'total_count\': total_actions\r\n                })\r\n\r\n            return execution_id\r\n\r\n        except Exception as e:\r\n            logger.error(f"Action sequence execution failed: {e}")\r\n            if self.execution_callback:\r\n                self.execution_callback({\r\n                    \'execution_id\': execution_id,\r\n                    \'status\': \'failed\',\r\n                    \'error\': str(e)\r\n                })\r\n            return execution_id\r\n        finally:\r\n            self.is_executing = False\r\n            self.current_execution_id = None\r\n\r\n    def _execute_single_action(self, action: Dict[str, Any]) -> bool:\r\n        """\r\n        Execute a single action based on its type and parameters.\r\n\r\n        Args:\r\n            action: Action dictionary with type and parameters\r\n\r\n        Returns:\r\n            True if action completed successfully, False otherwise\r\n        """\r\n        try:\r\n            action_type = action.get(\'action_type\', \'\').upper()\r\n            parameters = action.get(\'parameters\', {})\r\n            timeout = action.get(\'timeout\', 10.0)\r\n\r\n            logger.info(f"Executing action: {action_type} with params: {parameters}")\r\n\r\n            if action_type == \'NAVIGATE_TO\':\r\n                target_pos = parameters.get(\'target_position\', {})\r\n                x = target_pos.get(\'x\', 0.0)\r\n                y = target_pos.get(\'y\', 0.0)\r\n                z = target_pos.get(\'z\', 0.0)\r\n\r\n                return self.navigation_interface.navigate_to_pose(x, y, z, timeout)\r\n\r\n            elif action_type == \'GRASP_OBJECT\':\r\n                object_id = parameters.get(\'object_id\', \'\')\r\n                return self.manipulation_interface.grasp_object(object_id, timeout)\r\n\r\n            elif action_type == \'RELEASE_OBJECT\':\r\n                return self.manipulation_interface.release_object(timeout)\r\n\r\n            elif action_type == \'LOOK_AT\':\r\n                # In simulation, this might just be a pose adjustment\r\n                target_pos = parameters.get(\'target_position\', {})\r\n                x = target_pos.get(\'x\', 0.0)\r\n                y = target_pos.get(\'y\', 0.0)\r\n                z = target_pos.get(\'z\', 0.0)\r\n\r\n                # Navigate to look at the position\r\n                return self.navigation_interface.navigate_to_pose(x, y, z, timeout)\r\n\r\n            elif action_type == \'WAIT\':\r\n                duration = parameters.get(\'duration\', 1.0)\r\n                time.sleep(min(duration, timeout))\r\n                return True\r\n\r\n            elif action_type == \'REPORT_STATUS\':\r\n                message = parameters.get(\'message\', \'Status report\')\r\n                logger.info(f"Status report: {message}")\r\n                return True\r\n\r\n            else:\r\n                logger.warning(f"Unknown action type: {action_type}")\r\n                return False\r\n\r\n        except Exception as e:\r\n            logger.error(f"Action execution failed: {e}")\r\n            return False\r\n\r\n    def stop_current_execution(self):\r\n        """\r\n        Stop the currently executing action sequence.\r\n        """\r\n        if self.is_executing:\r\n            logger.info("Stopping current execution")\r\n            self.is_executing = False\r\n            if self.execution_callback:\r\n                self.execution_callback({\r\n                    \'execution_id\': self.current_execution_id,\r\n                    \'status\': \'cancelled\'\r\n                })\n'})}),"\n",(0,i.jsx)(n.h3,{id:"step-2-create-action-execution-manager",children:"Step 2: Create Action Execution Manager"}),"\n",(0,i.jsx)(n.p,{children:"Now let's create the main action execution manager that will coordinate the execution of action sequences:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/vla/ros2/action_execution_manager.py\r\n\r\nfrom typing import Dict, Any, List, Optional, Callable\r\nfrom enum import Enum\r\nimport time\r\nimport threading\r\nimport logging\r\nfrom dataclasses import dataclass\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass ExecutionStatus(Enum):\r\n    """Possible statuses for action execution."""\r\n    PENDING = "pending"\r\n    IN_PROGRESS = "in_progress"\r\n    SUCCESS = "success"\r\n    FAILED = "failed"\r\n    CANCELLED = "cancelled"\r\n    PAUSED = "paused"\r\n\r\n@dataclass\r\nclass ExecutionState:\r\n    """Current state of an action execution."""\r\n    execution_id: str\r\n    current_action_index: int\r\n    total_actions: int\r\n    status: ExecutionStatus\r\n    progress: float\r\n    error_message: Optional[str]\r\n    start_time: float\r\n    last_update: float\r\n    executed_actions: List[str]\r\n\r\nclass ActionExecutionManager:\r\n    """\r\n    Manages the execution of action sequences with state tracking and monitoring.\r\n    """\r\n\r\n    def __init__(self, action_executor_node):\r\n        """\r\n        Initialize action execution manager.\r\n\r\n        Args:\r\n            action_executor_node: ROS 2 node for action execution\r\n        """\r\n        self.action_executor = action_executor_node\r\n        self.active_executions = {}\r\n        self.execution_lock = threading.Lock()\r\n\r\n    def execute_intent(self,\r\n                      intent: Dict[str, Any],\r\n                      callback: Optional[Callable] = None) -> str:\r\n        """\r\n        Execute an intent with action sequence from cognitive planner.\r\n\r\n        Args:\r\n            intent: Processed intent with action sequence\r\n            callback: Optional callback for execution updates\r\n\r\n        Returns:\r\n            Execution ID for tracking\r\n        """\r\n        execution_id = f"intent_exec_{int(time.time())}"\r\n\r\n        # Create initial execution state\r\n        with self.execution_lock:\r\n            self.active_executions[execution_id] = ExecutionState(\r\n                execution_id=execution_id,\r\n                current_action_index=0,\r\n                total_actions=len(intent.get(\'action_sequence\', [])),\r\n                status=ExecutionStatus.PENDING,\r\n                progress=0.0,\r\n                error_message=None,\r\n                start_time=time.time(),\r\n                last_update=time.time(),\r\n                executed_actions=[]\r\n            )\r\n\r\n        # Update status\r\n        self._update_execution_state(execution_id, ExecutionStatus.IN_PROGRESS)\r\n\r\n        try:\r\n            # Execute the action sequence\r\n            action_sequence = intent.get(\'action_sequence\', [])\r\n            success = self.action_executor.execute_action_sequence(\r\n                action_sequence,\r\n                lambda status: self._handle_execution_update(execution_id, status, callback)\r\n            )\r\n\r\n            # Update final status based on success\r\n            final_status = ExecutionStatus.SUCCESS if success else ExecutionStatus.FAILED\r\n            self._update_execution_state(execution_id, final_status)\r\n\r\n            return execution_id\r\n\r\n        except Exception as e:\r\n            logger.error(f"Intent execution failed: {e}")\r\n            self._update_execution_state(execution_id, ExecutionStatus.FAILED, str(e))\r\n            if callback:\r\n                callback({\r\n                    \'execution_id\': execution_id,\r\n                    \'status\': \'failed\',\r\n                    \'error\': str(e)\r\n                })\r\n            return execution_id\r\n\r\n    def _handle_execution_update(self,\r\n                                execution_id: str,\r\n                                status_update: Dict[str, Any],\r\n                                user_callback: Optional[Callable]):\r\n        """\r\n        Handle execution update from the action executor.\r\n\r\n        Args:\r\n            execution_id: ID of the execution being updated\r\n            status_update: Status update from action executor\r\n            user_callback: User-provided callback function\r\n        """\r\n        # Update internal execution state\r\n        if \'current_action\' in status_update and \'total_actions\' in status_update:\r\n            progress = status_update[\'current_action\'] / status_update[\'total_actions\']\r\n            self._update_execution_state(\r\n                execution_id,\r\n                ExecutionStatus(status_update[\'status\']) if status_update[\'status\'] != \'executing\' else ExecutionStatus.IN_PROGRESS,\r\n                progress=progress\r\n            )\r\n\r\n        # Call user callback if provided\r\n        if user_callback:\r\n            user_callback(status_update)\r\n\r\n    def _update_execution_state(self,\r\n                               execution_id: str,\r\n                               status: ExecutionStatus,\r\n                               error_message: Optional[str] = None,\r\n                               progress: Optional[float] = None):\r\n        """\r\n        Update the state of an active execution.\r\n\r\n        Args:\r\n            execution_id: ID of execution to update\r\n            status: New status\r\n            error_message: Optional error message\r\n            progress: Optional progress value\r\n        """\r\n        with self.execution_lock:\r\n            if execution_id in self.active_executions:\r\n                exec_state = self.active_executions[execution_id]\r\n                exec_state.status = status\r\n                exec_state.last_update = time.time()\r\n\r\n                if error_message:\r\n                    exec_state.error_message = error_message\r\n\r\n                if progress is not None:\r\n                    exec_state.progress = progress\r\n\r\n    def get_execution_status(self, execution_id: str) -> Optional[ExecutionState]:\r\n        """\r\n        Get the current status of an execution.\r\n\r\n        Args:\r\n            execution_id: ID of execution to check\r\n\r\n        Returns:\r\n            ExecutionState if found, None otherwise\r\n        """\r\n        with self.execution_lock:\r\n            return self.active_executions.get(execution_id)\r\n\r\n    def cancel_execution(self, execution_id: str) -> bool:\r\n        """\r\n        Cancel a currently running execution.\r\n\r\n        Args:\r\n            execution_id: ID of execution to cancel\r\n\r\n        Returns:\r\n            True if cancellation was successful, False otherwise\r\n        """\r\n        with self.execution_lock:\r\n            if execution_id in self.active_executions:\r\n                self.active_executions[execution_id].status = ExecutionStatus.CANCELLED\r\n                self.active_executions[execution_id].last_update = time.time()\r\n\r\n                # Tell the action executor to stop\r\n                self.action_executor.stop_current_execution()\r\n\r\n                logger.info(f"Execution {execution_id} cancelled")\r\n                return True\r\n\r\n        return False\r\n\r\n    def get_active_executions(self) -> Dict[str, ExecutionState]:\r\n        """\r\n        Get all active executions.\r\n\r\n        Returns:\r\n            Dictionary mapping execution IDs to their states\r\n        """\r\n        with self.execution_lock:\r\n            return {\r\n                exec_id: exec_state\r\n                for exec_id, exec_state in self.active_executions.items()\r\n                if exec_state.status in [ExecutionStatus.PENDING, ExecutionStatus.IN_PROGRESS]\r\n            }\n'})}),"\n",(0,i.jsx)(n.h3,{id:"step-3-create-action-server-implementations",children:"Step 3: Create Action Server Implementations"}),"\n",(0,i.jsx)(n.p,{children:"Now let's create mock action server implementations for simulation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/vla/ros2/mock_action_servers.py\r\n\r\nimport rclpy\r\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\r\nfrom rclpy.node import Node\r\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup\r\nfrom rclpy.executors import MultiThreadedExecutor\r\nimport time\r\nimport threading\r\nfrom typing import Optional\r\nimport logging\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass MockNavigationServer(Node):\r\n    """\r\n    Mock navigation action server for simulation/testing.\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__(\'mock_navigation_server\')\r\n\r\n        # Create action server for navigation\r\n        self.navigation_server = ActionServer(\r\n            self,\r\n            # In a real system, this would be nav2_msgs.action.NavigateToPose\r\n            # For mock, we\'ll simulate the interface\r\n            self._handle_navigate_goal,\r\n            self._handle_navigate_cancel,\r\n            self._handle_navigate_accepted\r\n        )\r\n\r\n        logger.info("Mock navigation server initialized")\r\n\r\n    def _handle_navigate_goal(self, goal_handle):\r\n        """Handle navigation goal request."""\r\n        logger.info(f"Received navigation goal: {goal_handle.request}")\r\n\r\n        # Check if goal is acceptable\r\n        if self._is_goal_acceptable(goal_handle.request):\r\n            goal_handle.succeed()\r\n            result = self._execute_navigation(goal_handle.request)\r\n            return result\r\n        else:\r\n            goal_handle.abort()\r\n            return None\r\n\r\n    def _handle_navigate_cancel(self, goal_handle):\r\n        """Handle navigation goal cancellation."""\r\n        logger.info("Navigation goal cancelled")\r\n        return CancelResponse.ACCEPT\r\n\r\n    def _handle_navigate_accepted(self, goal_handle):\r\n        """Handle accepted navigation goal."""\r\n        logger.info("Navigation goal accepted")\r\n\r\n        # Execute in separate thread to not block the action server\r\n        execute_thread = threading.Thread(\r\n            target=self._execute_navigation_goal,\r\n            args=(goal_handle,)\r\n        )\r\n        execute_thread.start()\r\n\r\n    def _is_goal_acceptable(self, goal_request) -> bool:\r\n        """Check if navigation goal is acceptable."""\r\n        # Basic validation - in real system, check for obstacles, valid coordinates, etc.\r\n        target = goal_request.pose.pose.position\r\n        return (-10 <= target.x <= 10) and (-10 <= target.y <= 10)  # Reasonable bounds\r\n\r\n    def _execute_navigation(self, goal_request):\r\n        """Execute navigation (simulated)."""\r\n        # Simulate navigation execution\r\n        time.sleep(2.0)  # Simulate navigation time\r\n\r\n        # Return success result\r\n        # In a real system, this would be a proper result message\r\n        return {"success": True, "message": "Navigation completed successfully"}\r\n\r\n    def _execute_navigation_goal(self, goal_handle):\r\n        """Execute navigation goal in a separate thread."""\r\n        try:\r\n            # Simulate navigation with feedback\r\n            for i in range(10):  # Simulate 10 feedback updates\r\n                if goal_handle.is_cancel_requested:\r\n                    goal_handle.canceled()\r\n                    return\r\n\r\n                # Publish feedback\r\n                feedback = {"distance_remaining": 1.0 - (i * 0.1)}\r\n                goal_handle.publish_feedback(feedback)\r\n\r\n                time.sleep(0.2)  # Wait between feedback updates\r\n\r\n            # Complete successfully\r\n            result = self._execute_navigation(goal_handle.request)\r\n            goal_handle.succeed()\r\n\r\n        except Exception as e:\r\n            logger.error(f"Navigation execution failed: {e}")\r\n            goal_handle.abort()\r\n\r\nclass MockManipulationServer(Node):\r\n    """\r\n    Mock manipulation action server for simulation/testing.\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__(\'mock_manipulation_server\')\r\n\r\n        # For mock purposes, we\'ll just log the actions\r\n        logger.info("Mock manipulation server initialized")\r\n\r\n    def execute_grasp(self, object_id: str, timeout: float = 5.0) -> bool:\r\n        """Simulate grasp execution."""\r\n        logger.info(f"Simulating grasp of object: {object_id}")\r\n        time.sleep(min(2.0, timeout))\r\n        return True  # Simulate success\r\n\r\n    def execute_release(self, timeout: float = 3.0) -> bool:\r\n        """Simulate object release."""\r\n        logger.info("Simulating object release")\r\n        time.sleep(min(1.0, timeout))\r\n        return True  # Simulate success\r\n\r\ndef run_mock_servers():\r\n    """\r\n    Run mock action servers for testing and simulation.\r\n    """\r\n    logger.info("Starting mock action servers for simulation")\r\n\r\n    rclpy.init()\r\n\r\n    # Create mock servers\r\n    nav_server = MockNavigationServer()\r\n    manip_server = MockManipulationServer()\r\n\r\n    # Use multi-threaded executor to handle multiple servers\r\n    executor = MultiThreadedExecutor(num_threads=2)\r\n    executor.add_node(nav_server)\r\n    executor.add_node(manip_server)\r\n\r\n    try:\r\n        logger.info("Mock servers spinning...")\r\n        executor.spin()\r\n    except KeyboardInterrupt:\r\n        logger.info("Shutting down mock servers")\r\n    finally:\r\n        nav_server.destroy_node()\r\n        manip_server.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    run_mock_servers()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"step-4-integrate-with-vla-system",children:"Step 4: Integrate with VLA System"}),"\n",(0,i.jsx)(n.p,{children:"Now let's create the integration module that connects the action execution with the broader VLA system:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# src/vla/integration/vla_action_integrator.py\r\n\r\nfrom typing import Dict, Any, Optional, Callable\r\nfrom src.vla.ros2.action_execution_manager import ActionExecutionManager\r\nfrom src.vla.ros2.action_interfaces import ActionExecutorNode\r\nfrom src.vla.models.execution_state import ExecutionStatus\r\nimport logging\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass VLAActionIntegrator:\r\n    \"\"\"\r\n    Integrates action execution with the broader VLA system.\r\n    \"\"\"\r\n\r\n    def __init__(self, action_execution_manager: ActionExecutionManager):\r\n        \"\"\"\r\n        Initialize the VLA action integrator.\r\n\r\n        Args:\r\n            action_execution_manager: Action execution manager instance\r\n        \"\"\"\r\n        self.action_manager = action_execution_manager\r\n\r\n    def execute_intent_with_actions(self,\r\n                                  intent: Dict[str, Any],\r\n                                  callback: Optional[Callable] = None) -> str:\r\n        \"\"\"\r\n        Execute an intent through the action execution system.\r\n\r\n        Args:\r\n            intent: Processed intent with action sequence\r\n            callback: Optional callback for execution updates\r\n\r\n        Returns:\r\n            Execution ID for tracking\r\n        \"\"\"\r\n        logger.info(f\"Executing intent with {len(intent.get('action_sequence', []))} actions\")\r\n\r\n        # Execute the intent through the action manager\r\n        execution_id = self.action_manager.execute_intent(intent, callback)\r\n\r\n        logger.info(f\"Intent execution started with ID: {execution_id}\")\r\n        return execution_id\r\n\r\n    def monitor_execution(self, execution_id: str) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Monitor the status of an ongoing execution.\r\n\r\n        Args:\r\n            execution_id: ID of execution to monitor\r\n\r\n        Returns:\r\n            Dictionary with execution status and progress\r\n        \"\"\"\r\n        exec_state = self.action_manager.get_execution_status(execution_id)\r\n\r\n        if exec_state:\r\n            return {\r\n                'execution_id': exec_state.execution_id,\r\n                'status': exec_state.status.value,\r\n                'progress': exec_state.progress,\r\n                'current_action': exec_state.current_action_index,\r\n                'total_actions': exec_state.total_actions,\r\n                'error_message': exec_state.error_message,\r\n                'elapsed_time': time.time() - exec_state.start_time\r\n            }\r\n        else:\r\n            return {\r\n                'execution_id': execution_id,\r\n                'status': 'not_found',\r\n                'error': f'Execution {execution_id} not found'\r\n            }\r\n\r\n    def cancel_execution(self, execution_id: str) -> bool:\r\n        \"\"\"\r\n        Cancel a running execution.\r\n\r\n        Args:\r\n            execution_id: ID of execution to cancel\r\n\r\n        Returns:\r\n            True if cancellation was successful, False otherwise\r\n        \"\"\"\r\n        logger.info(f\"Cancelling execution: {execution_id}\")\r\n        return self.action_manager.cancel_execution(execution_id)\r\n\r\n    def validate_action_sequence(self, action_sequence: List[Dict[str, Any]]) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Validate an action sequence for execution feasibility.\r\n\r\n        Args:\r\n            action_sequence: List of actions to validate\r\n\r\n        Returns:\r\n            Dictionary with validation results\r\n        \"\"\"\r\n        validation_result = {\r\n            'is_valid': True,\r\n            'issues': [],\r\n            'warnings': [],\r\n            'suggestions': []\r\n        }\r\n\r\n        if not action_sequence:\r\n            validation_result['is_valid'] = False\r\n            validation_result['issues'].append(\"Action sequence is empty\")\r\n            return validation_result\r\n\r\n        # Validate each action in the sequence\r\n        for i, action in enumerate(action_sequence):\r\n            action_type = action.get('action_type', '').upper()\r\n\r\n            # Check required fields\r\n            if not action_type:\r\n                validation_result['issues'].append(f\"Action {i+1}: Missing action_type\")\r\n                continue\r\n\r\n            # Validate action-specific parameters\r\n            if action_type == 'NAVIGATE_TO':\r\n                target_pos = action.get('parameters', {}).get('target_position', {})\r\n                if not all(key in target_pos for key in ['x', 'y', 'z']):\r\n                    validation_result['issues'].append(f\"Action {i+1}: NAVIGATE_TO missing target_position parameters\")\r\n\r\n            elif action_type == 'GRASP_OBJECT':\r\n                object_id = action.get('parameters', {}).get('object_id')\r\n                if not object_id:\r\n                    validation_result['issues'].append(f\"Action {i+1}: GRASP_OBJECT missing object_id\")\r\n\r\n            elif action_type == 'RELEASE_OBJECT':\r\n                # RELEASE_OBJECT typically doesn't need specific parameters\r\n                pass\r\n\r\n            # Check timeout values\r\n            timeout = action.get('timeout', 10.0)\r\n            if timeout <= 0:\r\n                validation_result['warnings'].append(f\"Action {i+1}: Invalid timeout value: {timeout}\")\r\n\r\n        # Check for logical sequence (e.g., can't release before grasp in sequence)\r\n        action_types = [action.get('action_type', '').upper() for action in action_sequence]\r\n\r\n        # Look for impossible sequences\r\n        if 'RELEASE_OBJECT' in action_types and 'GRASP_OBJECT' not in action_types:\r\n            validation_result['warnings'].append(\"Sequence contains RELEASE_OBJECT without prior GRASP_OBJECT\")\r\n\r\n        return validation_result\r\n\r\n    def get_active_executions_summary(self) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Get a summary of all active executions.\r\n\r\n        Returns:\r\n            Dictionary with active execution summary\r\n        \"\"\"\r\n        active_executions = self.action_manager.get_active_executions()\r\n\r\n        summary = {\r\n            'total_active': len(active_executions),\r\n            'executions': []\r\n        }\r\n\r\n        for exec_id, exec_state in active_executions.items():\r\n            summary['executions'].append({\r\n                'id': exec_state.execution_id,\r\n                'status': exec_state.status.value,\r\n                'progress': exec_state.progress,\r\n                'actions_completed': exec_state.current_action_index,\r\n                'total_actions': exec_state.total_actions\r\n            })\r\n\r\n        return summary\n"})}),"\n",(0,i.jsx)(n.h2,{id:"practical-exercise",children:"Practical Exercise"}),"\n",(0,i.jsx)(n.h3,{id:"exercise-41-action-execution-implementation",children:"Exercise 4.1: Action Execution Implementation"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Setup"}),": Create a test script that integrates the action execution components with the cognitive planner."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Implementation"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# test_action_execution.py\r\nimport rclpy\r\nimport time\r\nimport json\r\nfrom src.vla.ros2.action_interfaces import ActionExecutorNode\r\nfrom src.vla.ros2.action_execution_manager import ActionExecutionManager\r\nfrom src.vla.integration.vla_action_integrator import VLAActionIntegrator\r\n\r\ndef main():\r\n    # Initialize ROS 2\r\n    rclpy.init()\r\n\r\n    # Create action executor node\r\n    action_executor = ActionExecutorNode()\r\n\r\n    # Create action execution manager\r\n    action_manager = ActionExecutionManager(action_executor)\r\n\r\n    # Create VLA action integrator\r\n    vla_action_integrator = VLAActionIntegrator(action_manager)\r\n\r\n    print(\"Action execution system initialized\")\r\n\r\n    # Create a test action sequence (simulating output from cognitive planner)\r\n    test_action_sequence = [\r\n        {\r\n            'id': 'nav_1',\r\n            'action_type': 'NAVIGATE_TO',\r\n            'parameters': {\r\n                'target_position': {'x': 1.0, 'y': 0.5, 'z': 0.0},\r\n                'description': 'Navigate to the table area'\r\n            },\r\n            'timeout': 15.0\r\n        },\r\n        {\r\n            'id': 'grasp_1',\r\n            'action_type': 'GRASP_OBJECT',\r\n            'parameters': {\r\n                'object_id': 'red_cube_123',\r\n                'description': 'Grasp the red cube'\r\n            },\r\n            'timeout': 10.0\r\n        },\r\n        {\r\n            'id': 'nav_2',\r\n            'action_type': 'NAVIGATE_TO',\r\n            'parameters': {\r\n                'target_position': {'x': 2.0, 'y': 1.0, 'z': 0.0},\r\n                'description': 'Navigate to the shelf'\r\n            },\r\n            'timeout': 15.0\r\n        },\r\n        {\r\n            'id': 'release_1',\r\n            'action_type': 'RELEASE_OBJECT',\r\n            'parameters': {\r\n                'description': 'Release the object at the shelf'\r\n            },\r\n            'timeout': 8.0\r\n        }\r\n    ]\r\n\r\n    # Create a test intent\r\n    test_intent = {\r\n        'id': 'test_intent_1',\r\n        'action_sequence': test_action_sequence,\r\n        'context_objects': [\r\n            {\r\n                'id': 'red_cube_123',\r\n                'class_name': 'cube',\r\n                'color': 'red',\r\n                'is_graspable': True\r\n            }\r\n        ],\r\n        'spatial_constraints': {},\r\n        'priority': 'medium'\r\n    }\r\n\r\n    print(f\"Created test intent with {len(test_action_sequence)} actions\")\r\n\r\n    # Define callback for execution updates\r\n    def execution_callback(status):\r\n        print(f\"Execution update: {json.dumps(status, indent=2)}\")\r\n\r\n    # Execute the intent\r\n    print(\"\\nStarting action sequence execution...\")\r\n    execution_id = vla_action_integrator.execute_intent_with_actions(\r\n        test_intent,\r\n        callback=execution_callback\r\n    )\r\n\r\n    print(f\"Execution started with ID: {execution_id}\")\r\n\r\n    # Monitor execution progress\r\n    print(\"\\nMonitoring execution progress:\")\r\n    while True:\r\n        status = vla_action_integrator.monitor_execution(execution_id)\r\n\r\n        if status['status'] in ['success', 'failed', 'cancelled', 'not_found']:\r\n            print(f\"Execution completed with status: {status['status']}\")\r\n            if 'error_message' in status and status['error_message']:\r\n                print(f\"Error: {status['error_message']}\")\r\n            break\r\n\r\n        print(f\"  Status: {status['status']}, Progress: {status['progress']:.2%}\")\r\n        time.sleep(1)  # Check every second\r\n\r\n    # Get summary of active executions\r\n    summary = vla_action_integrator.get_active_executions_summary()\r\n    print(f\"\\nActive executions summary: {summary}\")\r\n\r\n    # Cleanup\r\n    action_executor.destroy_node()\r\n    rclpy.shutdown()\r\n    print(\"\\nAction execution system shutdown\")\r\n\r\nif __name__ == \"__main__\":\r\n    main()\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Testing"}),": Run the test script to see how the action execution system processes action sequences and manages execution states."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"ros-2-action-interfaces",children:"ROS 2 Action Interfaces"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Action Servers"}),": Provide long-running services with feedback and status"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Action Clients"}),": Send goals to action servers and monitor progress"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Goal Tracking"}),": Monitor the status of sent goals"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feedback Mechanisms"}),": Receive ongoing feedback during action execution"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"execution-state-management",children:"Execution State Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Tracking"}),": Monitor progress through action sequences"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Detect and respond to action failures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cancellation"}),": Allow users to stop running executions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Recovery"}),": Implement strategies for handling failed actions"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"integration-with-simulation",children:"Integration with Simulation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Isaac Sim Interface"}),": Connect ROS 2 nodes with NVIDIA Isaac Sim"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Physics Simulation"}),": Ensure actions respect physical constraints"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sensor Feedback"}),": Use simulated sensors for state verification"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-challenges-and-solutions",children:"Common Challenges and Solutions"}),"\n",(0,i.jsx)(n.h3,{id:"challenge-1-action-timeout-management",children:"Challenge 1: Action Timeout Management"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": Actions may take longer than expected or hang indefinitely.\r\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Implement proper timeout mechanisms and action cancellation."]}),"\n",(0,i.jsx)(n.h3,{id:"challenge-2-state-synchronization",children:"Challenge 2: State Synchronization"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": Robot state may not match expected state after actions.\r\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Use feedback and state verification to ensure consistency."]}),"\n",(0,i.jsx)(n.h3,{id:"challenge-3-error-recovery",children:"Challenge 3: Error Recovery"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": Actions may fail due to environmental conditions.\r\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Implement retry logic and alternative action sequences."]}),"\n",(0,i.jsx)(n.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"How does the action executor handle different types of actions (navigation vs manipulation)?"}),"\n",(0,i.jsx)(n.li,{children:"What is the role of the execution manager in tracking execution progress?"}),"\n",(0,i.jsx)(n.li,{children:"How does the system handle action failures during execution?"}),"\n",(0,i.jsx)(n.li,{children:"What are the key components of the ROS 2 action execution architecture?"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"In this lesson, you have implemented the action execution component of the VLA system. You learned how to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement ROS 2 action clients for navigation and manipulation tasks"}),"\n",(0,i.jsx)(n.li,{children:"Execute action sequences generated by the cognitive planner"}),"\n",(0,i.jsx)(n.li,{children:"Monitor execution state and provide feedback to the VLA system"}),"\n",(0,i.jsx)(n.li,{children:"Handle action failures and implement recovery procedures"}),"\n",(0,i.jsx)(n.li,{children:"Integrate with simulation environments for safe testing"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The action execution system serves as the muscle of the VLA pipeline, translating high-level plans into concrete robotic behaviors. In the next lesson, you will integrate all VLA components into a complete system and work on the capstone project."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var r=t(6540);const i={},o=r.createContext(i);function a(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);