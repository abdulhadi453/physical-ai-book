"use strict";(globalThis.webpackChunkai_native_textbook_physical_ai_humanoid_robotics=globalThis.webpackChunkai_native_textbook_physical_ai_humanoid_robotics||[]).push([[8612],{1418:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"chapter-2/platform-differences","title":"Platform-Specific Differences: Gazebo vs Unity","description":"Overview","source":"@site/docs/chapter-2/platform-differences.md","sourceDirName":"chapter-2","slug":"/chapter-2/platform-differences","permalink":"/docs/chapter-2/platform-differences","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapter-2/platform-differences.md","tags":[],"version":"current","sidebarPosition":23,"frontMatter":{"sidebar_position":23},"sidebar":"tutorialSidebar","previous":{"title":"Cross-Platform Simulation Comparison Guide","permalink":"/docs/chapter-2/cross-platform-guide"},"next":{"title":"Quality Validation Guide for Digital Twin Simulation","permalink":"/docs/chapter-2/quality-validation"}}');var s=i(4848),t=i(8453);const l={sidebar_position:23},o="Platform-Specific Differences: Gazebo vs Unity",a={},c=[{value:"Overview",id:"overview",level:2},{value:"Architecture and Design Philosophy",id:"architecture-and-design-philosophy",level:2},{value:"Gazebo Architecture",id:"gazebo-architecture",level:3},{value:"Unity Architecture",id:"unity-architecture",level:3},{value:"Physics Simulation Differences",id:"physics-simulation-differences",level:2},{value:"Physics Engine Implementation",id:"physics-engine-implementation",level:3},{value:"Gazebo Physics",id:"gazebo-physics",level:4},{value:"Unity Physics",id:"unity-physics",level:4},{value:"Collision Detection",id:"collision-detection",level:3},{value:"Gazebo Collision Detection",id:"gazebo-collision-detection",level:4},{value:"Unity Collision Detection",id:"unity-collision-detection",level:4},{value:"Sensor Simulation Differences",id:"sensor-simulation-differences",level:2},{value:"LiDAR Implementation",id:"lidar-implementation",level:3},{value:"Gazebo LiDAR",id:"gazebo-lidar",level:4},{value:"Unity LiDAR",id:"unity-lidar",level:4},{value:"Camera Simulation",id:"camera-simulation",level:3},{value:"Gazebo Camera",id:"gazebo-camera",level:4},{value:"Unity Camera",id:"unity-camera",level:4},{value:"Development Workflow Differences",id:"development-workflow-differences",level:2},{value:"Model Creation and Import",id:"model-creation-and-import",level:3},{value:"Gazebo Models",id:"gazebo-models",level:4},{value:"Unity Models",id:"unity-models",level:4},{value:"Scripting and Programming",id:"scripting-and-programming",level:3},{value:"Gazebo Scripting",id:"gazebo-scripting",level:4},{value:"Unity Scripting",id:"unity-scripting",level:4},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Resource Usage",id:"resource-usage",level:3},{value:"Gazebo Resource Profile",id:"gazebo-resource-profile",level:4},{value:"Unity Resource Profile",id:"unity-resource-profile",level:4},{value:"Real-time Performance",id:"real-time-performance",level:3},{value:"Gazebo Performance",id:"gazebo-performance",level:4},{value:"Unity Performance",id:"unity-performance",level:4},{value:"Integration Capabilities",id:"integration-capabilities",level:2},{value:"Middleware Integration",id:"middleware-integration",level:3},{value:"Gazebo ROS Integration",id:"gazebo-ros-integration",level:4},{value:"Unity ROS Integration",id:"unity-ros-integration",level:4},{value:"External System Integration",id:"external-system-integration",level:3},{value:"Gazebo Integration",id:"gazebo-integration",level:4},{value:"Unity Integration",id:"unity-integration",level:4},{value:"Use Case Recommendations",id:"use-case-recommendations",level:2},{value:"Choose Gazebo When:",id:"choose-gazebo-when",level:3},{value:"Choose Unity When:",id:"choose-unity-when",level:3},{value:"Migration Considerations",id:"migration-considerations",level:2},{value:"From Gazebo to Unity",id:"from-gazebo-to-unity",level:3},{value:"From Unity to Gazebo",id:"from-unity-to-gazebo",level:3},{value:"Best Practices by Platform",id:"best-practices-by-platform",level:2},{value:"Gazebo Best Practices",id:"gazebo-best-practices",level:3},{value:"Unity Best Practices",id:"unity-best-practices",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"platform-specific-differences-gazebo-vs-unity",children:"Platform-Specific Differences: Gazebo vs Unity"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"This document details the specific differences between Gazebo and Unity simulation platforms, focusing on technical aspects, implementation approaches, and practical considerations for robotics applications. Understanding these differences is crucial for effective platform selection and implementation."}),"\n",(0,s.jsx)(n.h2,{id:"architecture-and-design-philosophy",children:"Architecture and Design Philosophy"}),"\n",(0,s.jsx)(n.h3,{id:"gazebo-architecture",children:"Gazebo Architecture"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo is designed specifically for robotics simulation with a modular architecture:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Core Components:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gazebo Server"}),": Physics simulation and world management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gazebo Client"}),": Visualization and user interface"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transport Layer"}),": Message passing between components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plugins System"}),": Extensible functionality through plugins"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Model Database"}),": Online repository of robot models"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Design Philosophy:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Robotics-first approach"}),"\n",(0,s.jsx)(n.li,{children:"Integration with robotics middleware (ROS/ROS2)"}),"\n",(0,s.jsx)(n.li,{children:"Physics accuracy prioritized over visual quality"}),"\n",(0,s.jsx)(n.li,{children:"Open-source and extensible"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"unity-architecture",children:"Unity Architecture"}),"\n",(0,s.jsx)(n.p,{children:"Unity is a general-purpose game engine adapted for robotics:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Core Components:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scene System"}),": Hierarchical object management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component System"}),": Entity-Component architecture"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scripting Backend"}),": C# scripting environment"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rendering Pipeline"}),": Advanced graphics rendering"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Asset Pipeline"}),": Resource management and optimization"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Design Philosophy:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Visual quality and user experience prioritized"}),"\n",(0,s.jsx)(n.li,{children:"Game development principles applied to robotics"}),"\n",(0,s.jsx)(n.li,{children:"Cross-platform deployment capabilities"}),"\n",(0,s.jsx)(n.li,{children:"Commercial product with extensive ecosystem"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"physics-simulation-differences",children:"Physics Simulation Differences"}),"\n",(0,s.jsx)(n.h3,{id:"physics-engine-implementation",children:"Physics Engine Implementation"}),"\n",(0,s.jsx)(n.h4,{id:"gazebo-physics",children:"Gazebo Physics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Gazebo physics configuration --\x3e\r\n<physics type="ode" name="default_physics">\r\n  <max_step_size>0.001</max_step_size>\r\n  <real_time_factor>1</real_time_factor>\r\n  <real_time_update_rate>1000</real_time_update_rate>\r\n  <gravity>0 0 -9.8</gravity>\r\n  <ode>\r\n    <solver>\r\n      <type>quick</type>\r\n      <iters>10</iters>\r\n      <sor>1.3</sor>\r\n    </solver>\r\n    <constraints>\r\n      <cfm>0.0</cfm>\r\n      <erp>0.2</erp>\r\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\r\n      <contact_surface_layer>0.001</contact_surface_layer>\r\n    </constraints>\r\n  </ode>\r\n</physics>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Characteristics:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multiple physics engines (ODE, Bullet, Simbody)"}),"\n",(0,s.jsx)(n.li,{children:"Robotics-specific parameters and tuning"}),"\n",(0,s.jsx)(n.li,{children:"Optimized for mechanical systems"}),"\n",(0,s.jsx)(n.li,{children:"Accurate multi-body dynamics"}),"\n",(0,s.jsx)(n.li,{children:"Extensive collision detection options"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unity-physics",children:"Unity Physics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Unity physics configuration\r\npublic class PhysicsConfiguration : MonoBehaviour\r\n{\r\n    [Header("Physics Settings")]\r\n    public float fixedTimestep = 0.02f; // 50 FPS physics\r\n    public int solverIterations = 6;\r\n    public int solverVelocityIterations = 1;\r\n    public float sleepThreshold = 0.005f;\r\n    public float defaultContactOffset = 0.01f;\r\n    public float bounceThreshold = 2.0f;\r\n\r\n    void Start()\r\n    {\r\n        // Configure Unity physics engine\r\n        Physics.defaultSolverIterations = solverIterations;\r\n        Physics.defaultSolverVelocityIterations = solverVelocityIterations;\r\n        Physics.sleepThreshold = sleepThreshold;\r\n        Physics.defaultContactOffset = defaultContactOffset;\r\n        Physics.bounceThreshold = bounceThreshold;\r\n        Time.fixedDeltaTime = fixedTimestep;\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Characteristics:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"NVIDIA PhysX engine"}),"\n",(0,s.jsx)(n.li,{children:"Game development optimization"}),"\n",(0,s.jsx)(n.li,{children:"Visual quality considerations"}),"\n",(0,s.jsx)(n.li,{children:"Different default parameters"}),"\n",(0,s.jsx)(n.li,{children:"Different constraint solving approach"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"collision-detection",children:"Collision Detection"}),"\n",(0,s.jsx)(n.h4,{id:"gazebo-collision-detection",children:"Gazebo Collision Detection"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collision Primitives"}),": Box, sphere, cylinder, mesh"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collision Engines"}),": ODE, Bullet, Simbody specific"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Contact Processing"}),": Detailed contact information"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": Optimized for robotics scenarios"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<collision name="collision">\r\n  <geometry>\r\n    <mesh>\r\n      <uri>model://my_robot/meshes/link1.stl</uri>\r\n      <scale>1 1 1</scale>\r\n    </mesh>\r\n  </geometry>\r\n  <surface>\r\n    <friction>\r\n      <ode>\r\n        <mu>1.0</mu>\r\n        <mu2>1.0</mu2>\r\n        <fdir1>0 0 0</fdir1>\r\n        <slip1>0.0</slip1>\r\n        <slip2>0.0</slip2>\r\n      </ode>\r\n    </friction>\r\n    <bounce>\r\n      <restitution_coefficient>0.1</restitution_coefficient>\r\n      <threshold>100000</threshold>\r\n    </bounce>\r\n    <contact>\r\n      <ode>\r\n        <soft_cfm>0</soft_cfm>\r\n        <soft_erp>0.2</soft_erp>\r\n        <kp>1e+13</kp>\r\n        <kd>1</kd>\r\n        <max_vel>100.0</max_vel>\r\n        <min_depth>0.0</min_depth>\r\n      </ode>\r\n    </contact>\r\n  </surface>\r\n</collision>\n'})}),"\n",(0,s.jsx)(n.h4,{id:"unity-collision-detection",children:"Unity Collision Detection"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collision Primitives"}),": Box, sphere, capsule, mesh, terrain"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collision Detection"}),": Discrete, continuous, continuous dynamic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Contact Processing"}),": Unity's contact system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": Optimized for game scenarios"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class CollisionHandler : MonoBehaviour\r\n{\r\n    void OnCollisionEnter(Collision collision)\r\n    {\r\n        foreach (ContactPoint contact in collision.contacts)\r\n        {\r\n            Debug.DrawRay(contact.point, contact.normal, Color.white);\r\n\r\n            // Process collision information\r\n            float impulse = collision.impulse.magnitude;\r\n            Vector3 contactPoint = contact.point;\r\n            Vector3 normal = contact.normal;\r\n        }\r\n    }\r\n\r\n    void Start()\r\n    {\r\n        // Configure collision detection mode\r\n        Rigidbody rb = GetComponent<Rigidbody>();\r\n        rb.collisionDetectionMode = CollisionDetectionMode.Continuous;\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"sensor-simulation-differences",children:"Sensor Simulation Differences"}),"\n",(0,s.jsx)(n.h3,{id:"lidar-implementation",children:"LiDAR Implementation"}),"\n",(0,s.jsx)(n.h4,{id:"gazebo-lidar",children:"Gazebo LiDAR"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<sensor type="ray" name="lidar_360">\r\n  <pose>0 0 0.3 0 0 0</pose>\r\n  <ray>\r\n    <scan>\r\n      <horizontal>\r\n        <samples>720</samples>\r\n        <resolution>1</resolution>\r\n        <min_angle>-3.14159</min_angle>  \x3c!-- -\u03c0 radians --\x3e\r\n        <max_angle>3.14159</max_angle>   \x3c!-- \u03c0 radians --\x3e\r\n      </horizontal>\r\n      <vertical>\r\n        <samples>16</samples>\r\n        <resolution>1</resolution>\r\n        <min_angle>-0.2618</min_angle>  \x3c!-- -15 degrees --\x3e\r\n        <max_angle>0.2618</max_angle>   \x3c!-- 15 degrees --\x3e\r\n      </vertical>\r\n    </scan>\r\n    <range>\r\n      <min>0.1</min>\r\n      <max>30.0</max>\r\n      <resolution>0.01</resolution>\r\n    </range>\r\n    <noise>\r\n      <type>gaussian</type>\r\n      <mean>0.0</mean>\r\n      <stddev>0.01</stddev>\r\n    </noise>\r\n  </ray>\r\n  <plugin name="lidar_controller" filename="libRayPlugin.so">\r\n    <alwaysOn>true</alwaysOn>\r\n    <topicName>/laser_scan</topicName>\r\n    <frameName>lidar_frame</frameName>\r\n    <updateRate>10</updateRate>\r\n  </plugin>\r\n</sensor>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Gazebo LiDAR Characteristics:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Native ray-tracing implementation"}),"\n",(0,s.jsx)(n.li,{children:"Direct integration with physics engine"}),"\n",(0,s.jsx)(n.li,{children:"Standard ROS message formats"}),"\n",(0,s.jsx)(n.li,{children:"Configurable beam patterns"}),"\n",(0,s.jsx)(n.li,{children:"Realistic noise models"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unity-lidar",children:"Unity LiDAR"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class UnityLiDAR : MonoBehaviour\r\n{\r\n    [Header("LiDAR Configuration")]\r\n    public int horizontalRays = 360;\r\n    public int verticalRays = 16;\r\n    public float range = 30f;\r\n    public float noiseStdDev = 0.01f;\r\n    public LayerMask detectionMask = -1;\r\n\r\n    private float[,] ranges; // [vertical, horizontal]\r\n\r\n    void Start()\r\n    {\r\n        ranges = new float[verticalRays, horizontalRays];\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        if (Time.time % 0.1f < Time.deltaTime) // 10Hz update\r\n        {\r\n            PerformScan();\r\n        }\r\n    }\r\n\r\n    void PerformScan()\r\n    {\r\n        float hAngleStep = (2 * Mathf.PI) / horizontalRays;\r\n        float vAngleStep = (2 * 0.2618f) / verticalRays; // 30 degrees total vertical\r\n\r\n        for (int v = 0; v < verticalRays; v++)\r\n        {\r\n            float vAngle = -0.2618f + v * vAngleStep; // -15 to +15 degrees\r\n\r\n            for (int h = 0; h < horizontalRays; h++)\r\n            {\r\n                float hAngle = h * hAngleStep;\r\n\r\n                // Calculate ray direction in world space\r\n                Vector3 direction = CalculateRayDirection(hAngle, vAngle);\r\n\r\n                // Perform raycast\r\n                RaycastHit hit;\r\n                if (Physics.Raycast(transform.position, direction, out hit, range, detectionMask))\r\n                {\r\n                    float distance = hit.distance;\r\n                    // Add noise\r\n                    distance += GaussianNoise(noiseStdDev);\r\n                    ranges[v, h] = distance;\r\n                }\r\n                else\r\n                {\r\n                    ranges[v, h] = range; // Max range if no hit\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    Vector3 CalculateRayDirection(float hAngle, float vAngle)\r\n    {\r\n        // Convert spherical to Cartesian coordinates\r\n        float x = Mathf.Cos(vAngle) * Mathf.Sin(hAngle);\r\n        float y = Mathf.Sin(vAngle);\r\n        float z = Mathf.Cos(vAngle) * Mathf.Cos(hAngle);\r\n\r\n        // Transform to world space\r\n        return transform.TransformDirection(new Vector3(x, y, z));\r\n    }\r\n\r\n    float GaussianNoise(float stdDev)\r\n    {\r\n        // Box-Muller transform\r\n        float u1 = Random.value;\r\n        float u2 = Random.value;\r\n        float normal = Mathf.Sqrt(-2.0f * Mathf.Log(u1)) * Mathf.Cos(2.0f * Mathf.PI * u2);\r\n        return normal * stdDev;\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Unity LiDAR Characteristics:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Custom raycasting implementation"}),"\n",(0,s.jsx)(n.li,{children:"Unity physics integration"}),"\n",(0,s.jsx)(n.li,{children:"Flexible configuration possible"}),"\n",(0,s.jsx)(n.li,{children:"Requires manual noise implementation"}),"\n",(0,s.jsx)(n.li,{children:"C# scripting approach"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"camera-simulation",children:"Camera Simulation"}),"\n",(0,s.jsx)(n.h4,{id:"gazebo-camera",children:"Gazebo Camera"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<sensor type="camera" name="rgb_camera">\r\n  <pose>0.1 0 0.2 0 0 0</pose>\r\n  <camera name="head">\r\n    <horizontal_fov>1.047</horizontal_fov> \x3c!-- 60 degrees --\x3e\r\n    <image>\r\n      <width>640</width>\r\n      <height>480</height>\r\n      <format>R8G8B8</format>\r\n    </image>\r\n    <clip>\r\n      <near>0.1</near>\r\n      <far>100</far>\r\n    </clip>\r\n    <noise>\r\n      <type>gaussian</type>\r\n      <mean>0.0</mean>\r\n      <stddev>0.007</stddev>\r\n    </noise>\r\n  </camera>\r\n  <plugin name="camera_controller" filename="libGazebo_ros_camera.so">\r\n    <alwaysOn>true</alwaysOn>\r\n    <updateRate>30.0</updateRate>\r\n    <cameraName>my_camera</cameraName>\r\n    <imageTopicName>image_raw</imageTopicName>\r\n    <cameraInfoTopicName>camera_info</cameraInfoTopicName>\r\n  </plugin>\r\n</sensor>\n'})}),"\n",(0,s.jsx)(n.h4,{id:"unity-camera",children:"Unity Camera"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class UnityCamera : MonoBehaviour\r\n{\r\n    [Header("Camera Configuration")]\r\n    public int width = 640;\r\n    public int height = 480;\r\n    public float fieldOfView = 60f;\r\n    public float nearClip = 0.1f;\r\n    public float farClip = 100f;\r\n    public float noiseStdDev = 0.007f;\r\n\r\n    private Camera cam;\r\n    private RenderTexture renderTexture;\r\n\r\n    void Start()\r\n    {\r\n        cam = GetComponent<Camera>();\r\n        ConfigureCamera();\r\n        CreateRenderTexture();\r\n    }\r\n\r\n    void ConfigureCamera()\r\n    {\r\n        cam.fieldOfView = fieldOfView;\r\n        cam.nearClipPlane = nearClip;\r\n        cam.farClipPlane = farClip;\r\n    }\r\n\r\n    void CreateRenderTexture()\r\n    {\r\n        renderTexture = new RenderTexture(width, height, 24);\r\n        cam.targetTexture = renderTexture;\r\n    }\r\n\r\n    // Function to capture and process image\r\n    public Texture2D CaptureImage()\r\n    {\r\n        RenderTexture.active = renderTexture;\r\n        Texture2D image = new Texture2D(width, height, TextureFormat.RGB24, false);\r\n        image.ReadPixels(new Rect(0, 0, width, height), 0, 0);\r\n        image.Apply();\r\n\r\n        // Apply noise if needed\r\n        ApplyImageNoise(image);\r\n\r\n        RenderTexture.active = null;\r\n        return image;\r\n    }\r\n\r\n    void ApplyImageNoise(Texture2D image)\r\n    {\r\n        // Apply noise to image pixels\r\n        Color[] pixels = image.GetPixels();\r\n        for (int i = 0; i < pixels.Length; i++)\r\n        {\r\n            float noise = GaussianNoise(noiseStdDev);\r\n            pixels[i] = AddNoiseToColor(pixels[i], noise);\r\n        }\r\n        image.SetPixels(pixels);\r\n        image.Apply();\r\n    }\r\n\r\n    Color AddNoiseToColor(Color color, float noise)\r\n    {\r\n        return new Color(\r\n            Mathf.Clamp01(color.r + noise),\r\n            Mathf.Clamp01(color.g + noise),\r\n            Mathf.Clamp01(color.b + noise),\r\n            color.a\r\n        );\r\n    }\r\n\r\n    float GaussianNoise(float stdDev)\r\n    {\r\n        float u1 = Random.value;\r\n        float u2 = Random.value;\r\n        float normal = Mathf.Sqrt(-2.0f * Mathf.Log(u1)) * Mathf.Cos(2.0f * Mathf.PI * u2);\r\n        return normal * stdDev;\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"development-workflow-differences",children:"Development Workflow Differences"}),"\n",(0,s.jsx)(n.h3,{id:"model-creation-and-import",children:"Model Creation and Import"}),"\n",(0,s.jsx)(n.h4,{id:"gazebo-models",children:"Gazebo Models"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Format"}),": SDF (Simulation Description Format) + meshes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Structure"}),": Model folders with specific directory structure"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Database"}),": Online model database integration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validation"}),": Built-in model validation tools"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"my_model/\r\n\u251c\u2500\u2500 model.config\r\n\u251c\u2500\u2500 model.sdf\r\n\u2514\u2500\u2500 meshes/\r\n    \u251c\u2500\u2500 link1.dae\r\n    \u2514\u2500\u2500 link2.stl\n"})}),"\n",(0,s.jsx)(n.h4,{id:"unity-models",children:"Unity Models"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Format"}),": FBX, OBJ, 3DS with Unity's import pipeline"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Structure"}),": Asset folders with Unity's organization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Database"}),": Asset store integration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validation"}),": Unity's import and validation system"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Assets/\r\n\u251c\u2500\u2500 Models/\r\n\u2502   \u251c\u2500\u2500 Robot.fbx\r\n\u2502   \u2514\u2500\u2500 Environment.fbx\r\n\u251c\u2500\u2500 Materials/\r\n\u2502   \u251c\u2500\u2500 Robot.mat\r\n\u2502   \u2514\u2500\u2500 Environment.mat\r\n\u2514\u2500\u2500 Prefabs/\r\n    \u2514\u2500\u2500 Robot.prefab\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scripting-and-programming",children:"Scripting and Programming"}),"\n",(0,s.jsx)(n.h4,{id:"gazebo-scripting",children:"Gazebo Scripting"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primary Languages"}),": C++, Python (with ROS)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Approach"}),": Plugin-based architecture"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration"}),": Direct physics engine access"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debugging"}),": Standard development tools"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Gazebo plugin example\r\n#include <gazebo/gazebo.hh>\r\n#include <gazebo/physics/physics.hh>\r\n\r\nclass CustomModelPlugin : public gazebo::ModelPlugin\r\n{\r\npublic:\r\n  void Load(gazebo::physics::ModelPtr _model, sdf::ElementPtr _sdf)\r\n  {\r\n    this->model = _model;\r\n    this->physics = this->model->GetWorld()->Physics();\r\n\r\n    // Connect to world update event\r\n    this->updateConnection = gazebo::event::Events::ConnectWorldUpdateBegin(\r\n        std::bind(&CustomModelPlugin::OnUpdate, this));\r\n  }\r\n\r\nprivate:\r\n  void OnUpdate()\r\n  {\r\n    // Custom simulation logic\r\n  }\r\n\r\nprivate:\r\n  gazebo::physics::ModelPtr model;\r\n  gazebo::physics::PhysicsEnginePtr physics;\r\n  gazebo::event::ConnectionPtr updateConnection;\r\n};\n"})}),"\n",(0,s.jsx)(n.h4,{id:"unity-scripting",children:"Unity Scripting"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primary Languages"}),": C# (Unity's scripting language)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Approach"}),": Component-based architecture"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration"}),": Unity's component system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debugging"}),": Unity editor debugging tools"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Unity component example\r\nusing UnityEngine;\r\n\r\npublic class RobotController : MonoBehaviour\r\n{\r\n    [Header("Movement Settings")]\r\n    public float speed = 5f;\r\n    public float rotationSpeed = 100f;\r\n\r\n    private Rigidbody rb;\r\n\r\n    void Start()\r\n    {\r\n        rb = GetComponent<Rigidbody>();\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        // Handle input\r\n        float moveInput = Input.GetAxis("Vertical");\r\n        float turnInput = Input.GetAxis("Horizontal");\r\n\r\n        // Apply movement\r\n        Vector3 movement = transform.forward * moveInput * speed * Time.deltaTime;\r\n        transform.Translate(movement, Space.World);\r\n\r\n        // Apply rotation\r\n        float turn = turnInput * rotationSpeed * Time.deltaTime;\r\n        transform.Rotate(Vector3.up, turn);\r\n    }\r\n\r\n    void FixedUpdate()\r\n    {\r\n        // Physics-related updates\r\n        if (rb != null)\r\n        {\r\n            // Apply physics forces if needed\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsx)(n.h3,{id:"resource-usage",children:"Resource Usage"}),"\n",(0,s.jsx)(n.h4,{id:"gazebo-resource-profile",children:"Gazebo Resource Profile"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CPU Usage"}),": Moderate to high for complex physics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Usage"}),": Moderate, scales with scene complexity"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GPU Usage"}),": Lower, focused on visualization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Usage"}),": High with ROS integration"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unity-resource-profile",children:"Unity Resource Profile"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CPU Usage"}),": Moderate, optimized for rendering"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Usage"}),": Higher due to asset management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GPU Usage"}),": High, advanced rendering pipeline"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Usage"}),": Lower without specific networking"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"real-time-performance",children:"Real-time Performance"}),"\n",(0,s.jsx)(n.h4,{id:"gazebo-performance",children:"Gazebo Performance"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics Update Rate"}),": Configurable, typically 1000 Hz"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Visualization Rate"}),": Dependent on hardware"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Determinism"}),": High, consistent physics steps"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Latency"}),": Lower for physics calculations"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unity-performance",children:"Unity Performance"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics Update Rate"}),": Fixed timestep, typically 50-90 Hz"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Visualization Rate"}),": High, optimized for smooth rendering"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Determinism"}),": Moderate, depends on rendering load"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Latency"}),": Lower for visual feedback"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"integration-capabilities",children:"Integration Capabilities"}),"\n",(0,s.jsx)(n.h3,{id:"middleware-integration",children:"Middleware Integration"}),"\n",(0,s.jsx)(n.h4,{id:"gazebo-ros-integration",children:"Gazebo ROS Integration"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Native Support"}),": Built-in ROS/ROS2 plugins"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Message Types"}),": Standard ROS sensor messages"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tools"}),": ROS control integration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ecosystem"}),": Extensive ROS robotics tools"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unity-ros-integration",children:"Unity ROS Integration"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plugin Required"}),": Unity Robotics Package"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Message Types"}),": Custom ROS message handling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tools"}),": ROS# or Unity Robotics libraries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ecosystem"}),": Growing but smaller than Gazebo's"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"external-system-integration",children:"External System Integration"}),"\n",(0,s.jsx)(n.h4,{id:"gazebo-integration",children:"Gazebo Integration"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hardware-in-the-loop"}),": Direct sensor/actuator interfaces"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Control Systems"}),": Native PID and controller support"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data Logging"}),": Built-in logging capabilities"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Analysis Tools"}),": Integration with robotics analysis tools"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unity-integration",children:"Unity Integration"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hardware-in-the-loop"}),": Custom implementation required"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Control Systems"}),": Flexible but requires custom development"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data Logging"}),": Unity's logging system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Analysis Tools"}),": Integration with Unity analytics"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"use-case-recommendations",children:"Use Case Recommendations"}),"\n",(0,s.jsx)(n.h3,{id:"choose-gazebo-when",children:"Choose Gazebo When:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primary Focus"}),": Robotics research and development"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics Accuracy"}),": High precision mechanical simulation required"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ROS Integration"}),": Existing ROS-based workflow"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-Robot"}),": Complex multi-robot scenarios"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Open Source"}),": Budget constraints or customization needs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Standards"}),": Compliance with robotics standards required"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"choose-unity-when",children:"Choose Unity When:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Visual Quality"}),": Photorealistic rendering needed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"User Experience"}),": High-quality visualization important"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"VR/AR"}),": Virtual or augmented reality applications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Game Mechanics"}),": Interactive or gamified training"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cross-Platform"}),": Deployment to multiple platforms"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Graphics"}),": Advanced rendering and visual effects"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"migration-considerations",children:"Migration Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"from-gazebo-to-unity",children:"From Gazebo to Unity"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics Adjustment"}),": Adapt to PhysX differences"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Workflow Change"}),": Learn Unity's component system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Visualization Upgrade"}),": Leverage Unity's rendering capabilities"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration Update"}),": Implement ROS bridges if needed"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"from-unity-to-gazebo",children:"From Unity to Gazebo"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics Learning"}),": Understand Gazebo's physics approach"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Workflow Change"}),": Adapt to plugin-based architecture"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ROS Integration"}),": Set up ROS communication"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Quality Trade-off"}),": Accept lower visual quality for accuracy"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-by-platform",children:"Best Practices by Platform"}),"\n",(0,s.jsx)(n.h3,{id:"gazebo-best-practices",children:"Gazebo Best Practices"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use appropriate physics parameters for your use case"}),"\n",(0,s.jsx)(n.li,{children:"Optimize collision meshes for performance"}),"\n",(0,s.jsx)(n.li,{children:"Validate models before simulation"}),"\n",(0,s.jsx)(n.li,{children:"Use plugins for custom functionality"}),"\n",(0,s.jsx)(n.li,{children:"Monitor real-time factor for performance"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"unity-best-practices",children:"Unity Best Practices"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implement Level of Detail (LOD) for complex models"}),"\n",(0,s.jsx)(n.li,{children:"Use object pooling for frequently created objects"}),"\n",(0,s.jsx)(n.li,{children:"Optimize draw calls and batching"}),"\n",(0,s.jsx)(n.li,{children:"Profile regularly for performance bottlenecks"}),"\n",(0,s.jsx)(n.li,{children:"Use Unity's built-in optimization tools"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"The choice between Gazebo and Unity depends on your specific requirements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gazebo"})," excels in robotics-specific applications requiring high physics accuracy, ROS integration, and multi-robot simulation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unity"})," excels in applications requiring high visual quality, user experience, and cross-platform deployment"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Both platforms can achieve good results for robotics simulation when properly configured and optimized for the specific use case. The key is understanding the fundamental differences and choosing the platform that best aligns with your project's primary requirements."}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Evaluate Your Needs"}),": Assess which platform characteristics are most important for your project"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prototype Approach"}),": Create small prototypes on both platforms to validate your choice"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance Testing"}),": Test both platforms with your specific scenarios"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Team Skills"}),": Consider your team's existing expertise with each platform"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Long-term Goals"}),": Plan for future evolution and maintenance of your simulation"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var r=i(6540);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);