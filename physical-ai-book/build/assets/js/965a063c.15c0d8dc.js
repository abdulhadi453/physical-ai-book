"use strict";(globalThis.webpackChunkai_native_textbook_physical_ai_humanoid_robotics=globalThis.webpackChunkai_native_textbook_physical_ai_humanoid_robotics||[]).push([[6312],{3544:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"chapter-1/lesson-1","title":"Lesson 1.1.1: Communication Primitives (Topics, Services, Actions)","description":"Understanding ROS 2 communication patterns and their applications","source":"@site/docs/chapter-1/lesson-1.md","sourceDirName":"chapter-1","slug":"/chapter-1/lesson-1","permalink":"/docs/chapter-1/lesson-1","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapter-1/lesson-1.md","tags":[{"inline":true,"label":"ros2","permalink":"/docs/tags/ros-2"},{"inline":true,"label":"communication","permalink":"/docs/tags/communication"},{"inline":true,"label":"topics","permalink":"/docs/tags/topics"},{"inline":true,"label":"services","permalink":"/docs/tags/services"},{"inline":true,"label":"actions","permalink":"/docs/tags/actions"},{"inline":true,"label":"ai-integration","permalink":"/docs/tags/ai-integration"}],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Lesson 1.1.1: Communication Primitives (Topics, Services, Actions)","description":"Understanding ROS 2 communication patterns and their applications","tags":["ros2","communication","topics","services","actions","ai-integration"]},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1.1: Introduction to ROS 2 as the Robotic Nervous System","permalink":"/docs/chapter-1/intro"},"next":{"title":"Lesson 1.1.2: rclpy for AI Agent Integration","permalink":"/docs/chapter-1/lesson-2"}}');var t=i(4848),o=i(8453);const r={sidebar_position:2,title:"Lesson 1.1.1: Communication Primitives (Topics, Services, Actions)",description:"Understanding ROS 2 communication patterns and their applications",tags:["ros2","communication","topics","services","actions","ai-integration"]},a="Lesson 1.1.1: Communication Primitives (Topics, Services, Actions)",c={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Content (500 words max)",id:"content-500-words-max",level:2},{value:"AI Agent Interaction Points",id:"ai-agent-interaction-points",level:2},{value:"Urdu Translation Markers",id:"urdu-translation-markers",level:2},{value:"Exercise",id:"exercise",level:2},{value:"Exercise Solution and Discussion",id:"exercise-solution-and-discussion",level:2},{value:"Summary and Key Takeaways",id:"summary-and-key-takeaways",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Assessment",id:"assessment",level:2}];function d(e){const n={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"lesson-111-communication-primitives-topics-services-actions",children:"Lesson 1.1.1: Communication Primitives (Topics, Services, Actions)"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Students will be able to differentiate between ROS 2 communication patterns (nodes, topics, services, actions)"}),"\n",(0,t.jsx)(n.li,{children:"Students will understand when to use each communication primitive for specific use cases"}),"\n",(0,t.jsx)(n.li,{children:"Students will demonstrate the ability to select appropriate patterns for given scenarios"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understanding of ROS 2 architecture from Module 1 intro"}),"\n",(0,t.jsx)(n.li,{children:"Basic Python knowledge"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"content-500-words-max",children:"Content (500 words max)"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 provides three primary communication patterns that enable different types of interactions between nodes: topics, services, and actions. Each pattern serves a specific purpose and is suited for different types of communication needs."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Topics"})," implement a publish-subscribe pattern where data flows continuously from publishers to subscribers. This is ideal for sensor data streams, state updates, or any information that needs to be broadcast continuously. For example, a camera node publishes image data to a topic, and multiple nodes (object detection, visualization, storage) can subscribe to receive the same stream. Topics are asynchronous and unidirectional, making them perfect for real-time data distribution."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Services"})," implement a request-response pattern where a client sends a request and waits for a response from a server. This is ideal for operations that have a clear start and end, like saving a map, transforming coordinates, or performing a computation. The communication is synchronous, meaning the client waits for the server to complete the operation before continuing."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Actions"})," are designed for long-running tasks that require feedback and the ability to cancel. They combine aspects of both topics and services, providing goal specification, continuous feedback, and result reporting. Actions are perfect for navigation tasks, where you want to send a goal (navigate to point X), receive continuous feedback (progress updates), and potentially cancel the operation if needed."]}),"\n",(0,t.jsx)(n.p,{children:"Understanding when to use each pattern is crucial for effective robotic system design. Use topics for continuous data streams, services for discrete operations with clear input/output, and actions for long-running tasks that need monitoring and control."}),"\n",(0,t.jsx)(n.h2,{id:"ai-agent-interaction-points",children:"AI Agent Interaction Points"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Explanation"}),": AI agents can provide additional examples of when to use each communication pattern"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Debugging"}),": AI agents can help troubleshoot communication pattern selection issues"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Examples"}),": AI agents can provide real-world examples from humanoid robotics"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"urdu-translation-markers",children:"Urdu Translation Markers"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Technical Term"}),": Topics - \u0679\u0627\u067e\u06a9\u0633"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Technical Term"}),": Services - \u0633\u0631\u0648\u0633\u0632"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Technical Term"}),": Actions - \u0627\u06cc\u06a9\u0634\u0646\u0632"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Key Concept"}),": Publish-Subscribe - \u067e\u0628\u0644\u0634-\u0633\u0628\u0633\u06a9\u0631\u0627\u0626\u0628"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"exercise",children:"Exercise"}),"\n",(0,t.jsx)(n.p,{children:"Create a scenario where a humanoid robot needs to navigate to a location, avoid obstacles, and report its status. Identify which communication patterns (topics, services, actions) would be appropriate for each part of the interaction and justify your choices."}),"\n",(0,t.jsx)(n.h2,{id:"exercise-solution-and-discussion",children:"Exercise Solution and Discussion"}),"\n",(0,t.jsx)(n.p,{children:"The navigation task would use actions (for long-running navigation with feedback), sensor data would use topics (for continuous obstacle detection), and map queries might use services (for discrete location lookups). Common mistakes include using services for continuous data or topics for goal-oriented tasks."}),"\n",(0,t.jsx)(n.h2,{id:"summary-and-key-takeaways",children:"Summary and Key Takeaways"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Topics: Continuous data streams, publish-subscribe pattern"}),"\n",(0,t.jsx)(n.li,{children:"Services: Request-response for discrete operations"}),"\n",(0,t.jsx)(n.li,{children:"Actions: Long-running tasks with feedback and cancellation"}),"\n",(0,t.jsx)(n.li,{children:"Pattern selection is crucial for effective system design"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Concepts/About-Topics.html",children:"ROS 2 Topics Documentation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Concepts/About-Services.html",children:"ROS 2 Services Documentation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Concepts/About-Actions.html",children:"ROS 2 Actions Documentation"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"assessment",children:"Assessment"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Differentiate between ROS 2 topics, services, and actions."}),"\n",(0,t.jsx)(n.li,{children:"Identify appropriate use cases for each communication pattern."}),"\n",(0,t.jsx)(n.li,{children:"Explain when to use each pattern in a humanoid robot system."}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);