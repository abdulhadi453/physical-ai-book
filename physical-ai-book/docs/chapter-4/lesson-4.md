# Lesson 4.1.4: ROS 2 Action Execution

## Overview

Welcome to Lesson 4 of the Vision-Language-Action (VLA) Systems module! In this lesson, you will implement the ROS 2 action execution component of the VLA system. This component is responsible for executing the action sequences generated by the cognitive planning system using ROS 2 action servers and clients. The action execution system bridges the gap between high-level planning and low-level robot control, translating abstract action steps into concrete robotic behaviors.

## Learning Objectives

By the end of this lesson, you will be able to:
1. Implement ROS 2 action servers for navigation and manipulation tasks
2. Create action clients that execute action sequences from the cognitive planner
3. Monitor execution state and provide feedback to the VLA system
4. Handle action failures and implement recovery procedures
5. Integrate with NVIDIA Isaac Sim for simulation-based execution

## Prerequisites

Before starting this lesson, ensure you have:
- Completed Lesson 1-3 (Voice Processing, Cognitive Planning, Visual Perception)
- Set up ROS 2 Humble Hawksbill with required packages
- Familiarized yourself with the VLA system architecture
- Understood basic concepts of ROS 2 actions, services, and topics
- Set up NVIDIA Isaac Sim environment for testing

## Action Execution Architecture

The action execution component follows this architecture:

```
Action Sequence → ROS 2 Action Client → Robot Control → Execution Feedback → VLA System
```

Key considerations include:
- Using ROS 2 action interfaces for long-running operations
- Implementing proper feedback and status reporting
- Handling action timeouts and failures gracefully
- Ensuring safety constraints during execution

## Implementation Steps

### Step 1: Set Up ROS 2 Action Definitions

First, let's create the action definition files that will be used for communication between the VLA system and robot controllers:

```python
# src/vla/ros2/action_interfaces.py

import rclpy
from rclpy.action import ActionClient, ActionServer
from rclpy.node import Node
from typing import Dict, Any, Optional, Callable
import time
import logging

logger = logging.getLogger(__name__)

class NavigationActionInterface:
    """
    Interface for navigation actions using ROS 2 action servers.
    """

    def __init__(self, node: Node):
        """
        Initialize navigation action interface.

        Args:
            node: ROS 2 node to use for action communication
        """
        self.node = node

        # Import navigation action types (these would be generated from .action files)
        try:
            from nav2_msgs.action import NavigateToPose
            self.NavigateToPose = NavigateToPose
        except ImportError:
            logger.warning("nav2_msgs not available, using mock navigation")
            self.NavigateToPose = None

        # Create action client for navigation
        self.nav_to_pose_client = None
        if self.NavigateToPose:
            self.nav_to_pose_client = ActionClient(
                node,
                self.NavigateToPose,
                'navigate_to_pose'
            )

    def navigate_to_pose(self,
                        x: float,
                        y: float,
                        z: float,
                        timeout: float = 30.0) -> bool:
        """
        Navigate to a specific pose using ROS 2 navigation action.

        Args:
            x: Target X coordinate
            y: Target Y coordinate
            z: Target Z coordinate (height)
            timeout: Maximum time to wait for completion

        Returns:
            True if navigation completed successfully, False otherwise
        """
        if not self.nav_to_pose_client:
            logger.warning("Navigation action client not available, simulating navigation")
            # Simulate navigation for testing
            time.sleep(min(2.0, timeout))
            return True

        try:
            # Wait for action server
            if not self.nav_to_pose_client.wait_for_server(timeout_sec=5.0):
                logger.error("Navigation action server not available")
                return False

            # Create goal message
            goal_msg = self.NavigateToPose.Goal()
            goal_msg.pose.header.frame_id = 'map'
            goal_msg.pose.header.stamp = self.node.get_clock().now().to_msg()

            goal_msg.pose.pose.position.x = float(x)
            goal_msg.pose.pose.position.y = float(y)
            goal_msg.pose.pose.position.z = float(z)
            # Set orientation to face forward (no rotation)
            goal_msg.pose.pose.orientation.w = 1.0

            # Send goal
            goal_future = self.nav_to_pose_client.send_goal_async(goal_msg)

            # Wait for result with timeout
            start_time = time.time()
            while time.time() - start_time < timeout:
                if goal_future.done():
                    goal_handle = goal_future.result()
                    if goal_handle.accepted:
                        logger.info("Navigation goal accepted, waiting for result...")

                        # Wait for result
                        result_future = goal_handle.get_result_async()

                        # Wait for result with remaining time
                        remaining_time = timeout - (time.time() - start_time)
                        if remaining_time > 0:
                            # In a real implementation, we'd properly wait for the result
                            # For simulation purposes, we'll return success after a brief delay
                            time.sleep(min(1.0, remaining_time))
                            return True
                    else:
                        logger.error("Navigation goal was rejected")
                        return False

                time.sleep(0.1)  # Small delay to prevent busy waiting

            logger.warning("Navigation timeout reached")
            return False

        except Exception as e:
            logger.error(f"Navigation failed: {e}")
            return False

class ManipulationActionInterface:
    """
    Interface for manipulation actions using ROS 2 action servers.
    """

    def __init__(self, node: Node):
        """
        Initialize manipulation action interface.

        Args:
            node: ROS 2 node to use for action communication
        """
        self.node = node

        # Mock action types for manipulation (in real system, these would be custom action types)
        self.grasp_action_client = None
        self.place_action_client = None

        # For now, we'll use a simple interface - in a real system, you'd have custom action types
        logger.info("Manipulation action interface initialized (mock implementation)")

    def grasp_object(self,
                    object_id: str,
                    timeout: float = 10.0) -> bool:
        """
        Execute grasp action for a specific object.

        Args:
            object_id: ID of the object to grasp
            timeout: Maximum time to wait for completion

        Returns:
            True if grasp completed successfully, False otherwise
        """
        try:
            logger.info(f"Attempting to grasp object: {object_id}")

            # In a real implementation, this would send a grasp action goal
            # For simulation, we'll simulate the grasp process
            time.sleep(min(2.0, timeout))

            # Simulate grasp success/failure based on object properties
            # In a real system, you'd check grasp success with sensors
            logger.info(f"Grasp completed for object: {object_id}")
            return True

        except Exception as e:
            logger.error(f"Grasp action failed: {e}")
            return False

    def release_object(self, timeout: float = 5.0) -> bool:
        """
        Execute release action to drop currently held object.

        Args:
            timeout: Maximum time to wait for completion

        Returns:
            True if release completed successfully, False otherwise
        """
        try:
            logger.info("Releasing currently held object")

            # In a real implementation, this would send a release action goal
            # For simulation, we'll simulate the release process
            time.sleep(min(1.0, timeout))

            logger.info("Object release completed")
            return True

        except Exception as e:
            logger.error(f"Release action failed: {e}")
            return False

class ActionExecutorNode(Node):
    """
    ROS 2 node that executes action sequences generated by the cognitive planner.
    """

    def __init__(self):
        """
        Initialize action executor node.
        """
        super().__init__('vla_action_executor')

        # Initialize action interfaces
        self.navigation_interface = NavigationActionInterface(self)
        self.manipulation_interface = ManipulationActionInterface(self)

        # Execution state tracking
        self.current_execution_id = None
        self.is_executing = False
        self.execution_callback = None

        logger.info("VLA Action Executor node initialized")

    def execute_action_sequence(self,
                              action_sequence: list,
                              callback: Optional[Callable] = None) -> str:
        """
        Execute a sequence of actions generated by the cognitive planner.

        Args:
            action_sequence: List of action steps to execute
            callback: Optional callback function for execution updates

        Returns:
            Execution ID for tracking
        """
        execution_id = f"exec_{int(time.time())}"
        self.current_execution_id = execution_id
        self.execution_callback = callback
        self.is_executing = True

        logger.info(f"Starting execution {execution_id} with {len(action_sequence)} actions")

        try:
            success_count = 0
            total_actions = len(action_sequence)

            for i, action in enumerate(action_sequence):
                if not self.is_executing:
                    logger.info("Execution stopped by user")
                    break

                # Report progress
                if self.execution_callback:
                    self.execution_callback({
                        'execution_id': execution_id,
                        'current_action': i + 1,
                        'total_actions': total_actions,
                        'status': 'executing',
                        'progress': (i + 1) / total_actions
                    })

                # Execute the action
                action_success = self._execute_single_action(action)

                if action_success:
                    success_count += 1
                    logger.info(f"Action {i+1}/{total_actions} completed successfully")
                else:
                    logger.error(f"Action {i+1}/{total_actions} failed")
                    # Optionally stop execution on failure, or continue with next action
                    # For now, we'll continue to next action
                    continue

            # Report final status
            if self.execution_callback:
                self.execution_callback({
                    'execution_id': execution_id,
                    'current_action': total_actions,
                    'total_actions': total_actions,
                    'status': 'completed',
                    'progress': 1.0,
                    'success_count': success_count,
                    'total_count': total_actions
                })

            return execution_id

        except Exception as e:
            logger.error(f"Action sequence execution failed: {e}")
            if self.execution_callback:
                self.execution_callback({
                    'execution_id': execution_id,
                    'status': 'failed',
                    'error': str(e)
                })
            return execution_id
        finally:
            self.is_executing = False
            self.current_execution_id = None

    def _execute_single_action(self, action: Dict[str, Any]) -> bool:
        """
        Execute a single action based on its type and parameters.

        Args:
            action: Action dictionary with type and parameters

        Returns:
            True if action completed successfully, False otherwise
        """
        try:
            action_type = action.get('action_type', '').upper()
            parameters = action.get('parameters', {})
            timeout = action.get('timeout', 10.0)

            logger.info(f"Executing action: {action_type} with params: {parameters}")

            if action_type == 'NAVIGATE_TO':
                target_pos = parameters.get('target_position', {})
                x = target_pos.get('x', 0.0)
                y = target_pos.get('y', 0.0)
                z = target_pos.get('z', 0.0)

                return self.navigation_interface.navigate_to_pose(x, y, z, timeout)

            elif action_type == 'GRASP_OBJECT':
                object_id = parameters.get('object_id', '')
                return self.manipulation_interface.grasp_object(object_id, timeout)

            elif action_type == 'RELEASE_OBJECT':
                return self.manipulation_interface.release_object(timeout)

            elif action_type == 'LOOK_AT':
                # In simulation, this might just be a pose adjustment
                target_pos = parameters.get('target_position', {})
                x = target_pos.get('x', 0.0)
                y = target_pos.get('y', 0.0)
                z = target_pos.get('z', 0.0)

                # Navigate to look at the position
                return self.navigation_interface.navigate_to_pose(x, y, z, timeout)

            elif action_type == 'WAIT':
                duration = parameters.get('duration', 1.0)
                time.sleep(min(duration, timeout))
                return True

            elif action_type == 'REPORT_STATUS':
                message = parameters.get('message', 'Status report')
                logger.info(f"Status report: {message}")
                return True

            else:
                logger.warning(f"Unknown action type: {action_type}")
                return False

        except Exception as e:
            logger.error(f"Action execution failed: {e}")
            return False

    def stop_current_execution(self):
        """
        Stop the currently executing action sequence.
        """
        if self.is_executing:
            logger.info("Stopping current execution")
            self.is_executing = False
            if self.execution_callback:
                self.execution_callback({
                    'execution_id': self.current_execution_id,
                    'status': 'cancelled'
                })
```

### Step 2: Create Action Execution Manager

Now let's create the main action execution manager that will coordinate the execution of action sequences:

```python
# src/vla/ros2/action_execution_manager.py

from typing import Dict, Any, List, Optional, Callable
from enum import Enum
import time
import threading
import logging
from dataclasses import dataclass

logger = logging.getLogger(__name__)

class ExecutionStatus(Enum):
    """Possible statuses for action execution."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILED = "failed"
    CANCELLED = "cancelled"
    PAUSED = "paused"

@dataclass
class ExecutionState:
    """Current state of an action execution."""
    execution_id: str
    current_action_index: int
    total_actions: int
    status: ExecutionStatus
    progress: float
    error_message: Optional[str]
    start_time: float
    last_update: float
    executed_actions: List[str]

class ActionExecutionManager:
    """
    Manages the execution of action sequences with state tracking and monitoring.
    """

    def __init__(self, action_executor_node):
        """
        Initialize action execution manager.

        Args:
            action_executor_node: ROS 2 node for action execution
        """
        self.action_executor = action_executor_node
        self.active_executions = {}
        self.execution_lock = threading.Lock()

    def execute_intent(self,
                      intent: Dict[str, Any],
                      callback: Optional[Callable] = None) -> str:
        """
        Execute an intent with action sequence from cognitive planner.

        Args:
            intent: Processed intent with action sequence
            callback: Optional callback for execution updates

        Returns:
            Execution ID for tracking
        """
        execution_id = f"intent_exec_{int(time.time())}"

        # Create initial execution state
        with self.execution_lock:
            self.active_executions[execution_id] = ExecutionState(
                execution_id=execution_id,
                current_action_index=0,
                total_actions=len(intent.get('action_sequence', [])),
                status=ExecutionStatus.PENDING,
                progress=0.0,
                error_message=None,
                start_time=time.time(),
                last_update=time.time(),
                executed_actions=[]
            )

        # Update status
        self._update_execution_state(execution_id, ExecutionStatus.IN_PROGRESS)

        try:
            # Execute the action sequence
            action_sequence = intent.get('action_sequence', [])
            success = self.action_executor.execute_action_sequence(
                action_sequence,
                lambda status: self._handle_execution_update(execution_id, status, callback)
            )

            # Update final status based on success
            final_status = ExecutionStatus.SUCCESS if success else ExecutionStatus.FAILED
            self._update_execution_state(execution_id, final_status)

            return execution_id

        except Exception as e:
            logger.error(f"Intent execution failed: {e}")
            self._update_execution_state(execution_id, ExecutionStatus.FAILED, str(e))
            if callback:
                callback({
                    'execution_id': execution_id,
                    'status': 'failed',
                    'error': str(e)
                })
            return execution_id

    def _handle_execution_update(self,
                                execution_id: str,
                                status_update: Dict[str, Any],
                                user_callback: Optional[Callable]):
        """
        Handle execution update from the action executor.

        Args:
            execution_id: ID of the execution being updated
            status_update: Status update from action executor
            user_callback: User-provided callback function
        """
        # Update internal execution state
        if 'current_action' in status_update and 'total_actions' in status_update:
            progress = status_update['current_action'] / status_update['total_actions']
            self._update_execution_state(
                execution_id,
                ExecutionStatus(status_update['status']) if status_update['status'] != 'executing' else ExecutionStatus.IN_PROGRESS,
                progress=progress
            )

        # Call user callback if provided
        if user_callback:
            user_callback(status_update)

    def _update_execution_state(self,
                               execution_id: str,
                               status: ExecutionStatus,
                               error_message: Optional[str] = None,
                               progress: Optional[float] = None):
        """
        Update the state of an active execution.

        Args:
            execution_id: ID of execution to update
            status: New status
            error_message: Optional error message
            progress: Optional progress value
        """
        with self.execution_lock:
            if execution_id in self.active_executions:
                exec_state = self.active_executions[execution_id]
                exec_state.status = status
                exec_state.last_update = time.time()

                if error_message:
                    exec_state.error_message = error_message

                if progress is not None:
                    exec_state.progress = progress

    def get_execution_status(self, execution_id: str) -> Optional[ExecutionState]:
        """
        Get the current status of an execution.

        Args:
            execution_id: ID of execution to check

        Returns:
            ExecutionState if found, None otherwise
        """
        with self.execution_lock:
            return self.active_executions.get(execution_id)

    def cancel_execution(self, execution_id: str) -> bool:
        """
        Cancel a currently running execution.

        Args:
            execution_id: ID of execution to cancel

        Returns:
            True if cancellation was successful, False otherwise
        """
        with self.execution_lock:
            if execution_id in self.active_executions:
                self.active_executions[execution_id].status = ExecutionStatus.CANCELLED
                self.active_executions[execution_id].last_update = time.time()

                # Tell the action executor to stop
                self.action_executor.stop_current_execution()

                logger.info(f"Execution {execution_id} cancelled")
                return True

        return False

    def get_active_executions(self) -> Dict[str, ExecutionState]:
        """
        Get all active executions.

        Returns:
            Dictionary mapping execution IDs to their states
        """
        with self.execution_lock:
            return {
                exec_id: exec_state
                for exec_id, exec_state in self.active_executions.items()
                if exec_state.status in [ExecutionStatus.PENDING, ExecutionStatus.IN_PROGRESS]
            }
```

### Step 3: Create Action Server Implementations

Now let's create mock action server implementations for simulation:

```python
# src/vla/ros2/mock_action_servers.py

import rclpy
from rclpy.action import ActionServer, GoalResponse, CancelResponse
from rclpy.node import Node
from rclpy.callback_groups import MutuallyExclusiveCallbackGroup
from rclpy.executors import MultiThreadedExecutor
import time
import threading
from typing import Optional
import logging

logger = logging.getLogger(__name__)

class MockNavigationServer(Node):
    """
    Mock navigation action server for simulation/testing.
    """

    def __init__(self):
        super().__init__('mock_navigation_server')

        # Create action server for navigation
        self.navigation_server = ActionServer(
            self,
            # In a real system, this would be nav2_msgs.action.NavigateToPose
            # For mock, we'll simulate the interface
            self._handle_navigate_goal,
            self._handle_navigate_cancel,
            self._handle_navigate_accepted
        )

        logger.info("Mock navigation server initialized")

    def _handle_navigate_goal(self, goal_handle):
        """Handle navigation goal request."""
        logger.info(f"Received navigation goal: {goal_handle.request}")

        # Check if goal is acceptable
        if self._is_goal_acceptable(goal_handle.request):
            goal_handle.succeed()
            result = self._execute_navigation(goal_handle.request)
            return result
        else:
            goal_handle.abort()
            return None

    def _handle_navigate_cancel(self, goal_handle):
        """Handle navigation goal cancellation."""
        logger.info("Navigation goal cancelled")
        return CancelResponse.ACCEPT

    def _handle_navigate_accepted(self, goal_handle):
        """Handle accepted navigation goal."""
        logger.info("Navigation goal accepted")

        # Execute in separate thread to not block the action server
        execute_thread = threading.Thread(
            target=self._execute_navigation_goal,
            args=(goal_handle,)
        )
        execute_thread.start()

    def _is_goal_acceptable(self, goal_request) -> bool:
        """Check if navigation goal is acceptable."""
        # Basic validation - in real system, check for obstacles, valid coordinates, etc.
        target = goal_request.pose.pose.position
        return (-10 <= target.x <= 10) and (-10 <= target.y <= 10)  # Reasonable bounds

    def _execute_navigation(self, goal_request):
        """Execute navigation (simulated)."""
        # Simulate navigation execution
        time.sleep(2.0)  # Simulate navigation time

        # Return success result
        # In a real system, this would be a proper result message
        return {"success": True, "message": "Navigation completed successfully"}

    def _execute_navigation_goal(self, goal_handle):
        """Execute navigation goal in a separate thread."""
        try:
            # Simulate navigation with feedback
            for i in range(10):  # Simulate 10 feedback updates
                if goal_handle.is_cancel_requested:
                    goal_handle.canceled()
                    return

                # Publish feedback
                feedback = {"distance_remaining": 1.0 - (i * 0.1)}
                goal_handle.publish_feedback(feedback)

                time.sleep(0.2)  # Wait between feedback updates

            # Complete successfully
            result = self._execute_navigation(goal_handle.request)
            goal_handle.succeed()

        except Exception as e:
            logger.error(f"Navigation execution failed: {e}")
            goal_handle.abort()

class MockManipulationServer(Node):
    """
    Mock manipulation action server for simulation/testing.
    """

    def __init__(self):
        super().__init__('mock_manipulation_server')

        # For mock purposes, we'll just log the actions
        logger.info("Mock manipulation server initialized")

    def execute_grasp(self, object_id: str, timeout: float = 5.0) -> bool:
        """Simulate grasp execution."""
        logger.info(f"Simulating grasp of object: {object_id}")
        time.sleep(min(2.0, timeout))
        return True  # Simulate success

    def execute_release(self, timeout: float = 3.0) -> bool:
        """Simulate object release."""
        logger.info("Simulating object release")
        time.sleep(min(1.0, timeout))
        return True  # Simulate success

def run_mock_servers():
    """
    Run mock action servers for testing and simulation.
    """
    logger.info("Starting mock action servers for simulation")

    rclpy.init()

    # Create mock servers
    nav_server = MockNavigationServer()
    manip_server = MockManipulationServer()

    # Use multi-threaded executor to handle multiple servers
    executor = MultiThreadedExecutor(num_threads=2)
    executor.add_node(nav_server)
    executor.add_node(manip_server)

    try:
        logger.info("Mock servers spinning...")
        executor.spin()
    except KeyboardInterrupt:
        logger.info("Shutting down mock servers")
    finally:
        nav_server.destroy_node()
        manip_server.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    run_mock_servers()
```

### Step 4: Integrate with VLA System

Now let's create the integration module that connects the action execution with the broader VLA system:

```python
# src/vla/integration/vla_action_integrator.py

from typing import Dict, Any, Optional, Callable
from src.vla.ros2.action_execution_manager import ActionExecutionManager
from src.vla.ros2.action_interfaces import ActionExecutorNode
from src.vla.models.execution_state import ExecutionStatus
import logging

logger = logging.getLogger(__name__)

class VLAActionIntegrator:
    """
    Integrates action execution with the broader VLA system.
    """

    def __init__(self, action_execution_manager: ActionExecutionManager):
        """
        Initialize the VLA action integrator.

        Args:
            action_execution_manager: Action execution manager instance
        """
        self.action_manager = action_execution_manager

    def execute_intent_with_actions(self,
                                  intent: Dict[str, Any],
                                  callback: Optional[Callable] = None) -> str:
        """
        Execute an intent through the action execution system.

        Args:
            intent: Processed intent with action sequence
            callback: Optional callback for execution updates

        Returns:
            Execution ID for tracking
        """
        logger.info(f"Executing intent with {len(intent.get('action_sequence', []))} actions")

        # Execute the intent through the action manager
        execution_id = self.action_manager.execute_intent(intent, callback)

        logger.info(f"Intent execution started with ID: {execution_id}")
        return execution_id

    def monitor_execution(self, execution_id: str) -> Dict[str, Any]:
        """
        Monitor the status of an ongoing execution.

        Args:
            execution_id: ID of execution to monitor

        Returns:
            Dictionary with execution status and progress
        """
        exec_state = self.action_manager.get_execution_status(execution_id)

        if exec_state:
            return {
                'execution_id': exec_state.execution_id,
                'status': exec_state.status.value,
                'progress': exec_state.progress,
                'current_action': exec_state.current_action_index,
                'total_actions': exec_state.total_actions,
                'error_message': exec_state.error_message,
                'elapsed_time': time.time() - exec_state.start_time
            }
        else:
            return {
                'execution_id': execution_id,
                'status': 'not_found',
                'error': f'Execution {execution_id} not found'
            }

    def cancel_execution(self, execution_id: str) -> bool:
        """
        Cancel a running execution.

        Args:
            execution_id: ID of execution to cancel

        Returns:
            True if cancellation was successful, False otherwise
        """
        logger.info(f"Cancelling execution: {execution_id}")
        return self.action_manager.cancel_execution(execution_id)

    def validate_action_sequence(self, action_sequence: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Validate an action sequence for execution feasibility.

        Args:
            action_sequence: List of actions to validate

        Returns:
            Dictionary with validation results
        """
        validation_result = {
            'is_valid': True,
            'issues': [],
            'warnings': [],
            'suggestions': []
        }

        if not action_sequence:
            validation_result['is_valid'] = False
            validation_result['issues'].append("Action sequence is empty")
            return validation_result

        # Validate each action in the sequence
        for i, action in enumerate(action_sequence):
            action_type = action.get('action_type', '').upper()

            # Check required fields
            if not action_type:
                validation_result['issues'].append(f"Action {i+1}: Missing action_type")
                continue

            # Validate action-specific parameters
            if action_type == 'NAVIGATE_TO':
                target_pos = action.get('parameters', {}).get('target_position', {})
                if not all(key in target_pos for key in ['x', 'y', 'z']):
                    validation_result['issues'].append(f"Action {i+1}: NAVIGATE_TO missing target_position parameters")

            elif action_type == 'GRASP_OBJECT':
                object_id = action.get('parameters', {}).get('object_id')
                if not object_id:
                    validation_result['issues'].append(f"Action {i+1}: GRASP_OBJECT missing object_id")

            elif action_type == 'RELEASE_OBJECT':
                # RELEASE_OBJECT typically doesn't need specific parameters
                pass

            # Check timeout values
            timeout = action.get('timeout', 10.0)
            if timeout <= 0:
                validation_result['warnings'].append(f"Action {i+1}: Invalid timeout value: {timeout}")

        # Check for logical sequence (e.g., can't release before grasp in sequence)
        action_types = [action.get('action_type', '').upper() for action in action_sequence]

        # Look for impossible sequences
        if 'RELEASE_OBJECT' in action_types and 'GRASP_OBJECT' not in action_types:
            validation_result['warnings'].append("Sequence contains RELEASE_OBJECT without prior GRASP_OBJECT")

        return validation_result

    def get_active_executions_summary(self) -> Dict[str, Any]:
        """
        Get a summary of all active executions.

        Returns:
            Dictionary with active execution summary
        """
        active_executions = self.action_manager.get_active_executions()

        summary = {
            'total_active': len(active_executions),
            'executions': []
        }

        for exec_id, exec_state in active_executions.items():
            summary['executions'].append({
                'id': exec_state.execution_id,
                'status': exec_state.status.value,
                'progress': exec_state.progress,
                'actions_completed': exec_state.current_action_index,
                'total_actions': exec_state.total_actions
            })

        return summary
```

## Practical Exercise

### Exercise 4.1: Action Execution Implementation

1. **Setup**: Create a test script that integrates the action execution components with the cognitive planner.

2. **Implementation**:
   ```python
   # test_action_execution.py
   import rclpy
   import time
   import json
   from src.vla.ros2.action_interfaces import ActionExecutorNode
   from src.vla.ros2.action_execution_manager import ActionExecutionManager
   from src.vla.integration.vla_action_integrator import VLAActionIntegrator

   def main():
       # Initialize ROS 2
       rclpy.init()

       # Create action executor node
       action_executor = ActionExecutorNode()

       # Create action execution manager
       action_manager = ActionExecutionManager(action_executor)

       # Create VLA action integrator
       vla_action_integrator = VLAActionIntegrator(action_manager)

       print("Action execution system initialized")

       # Create a test action sequence (simulating output from cognitive planner)
       test_action_sequence = [
           {
               'id': 'nav_1',
               'action_type': 'NAVIGATE_TO',
               'parameters': {
                   'target_position': {'x': 1.0, 'y': 0.5, 'z': 0.0},
                   'description': 'Navigate to the table area'
               },
               'timeout': 15.0
           },
           {
               'id': 'grasp_1',
               'action_type': 'GRASP_OBJECT',
               'parameters': {
                   'object_id': 'red_cube_123',
                   'description': 'Grasp the red cube'
               },
               'timeout': 10.0
           },
           {
               'id': 'nav_2',
               'action_type': 'NAVIGATE_TO',
               'parameters': {
                   'target_position': {'x': 2.0, 'y': 1.0, 'z': 0.0},
                   'description': 'Navigate to the shelf'
               },
               'timeout': 15.0
           },
           {
               'id': 'release_1',
               'action_type': 'RELEASE_OBJECT',
               'parameters': {
                   'description': 'Release the object at the shelf'
               },
               'timeout': 8.0
           }
       ]

       # Create a test intent
       test_intent = {
           'id': 'test_intent_1',
           'action_sequence': test_action_sequence,
           'context_objects': [
               {
                   'id': 'red_cube_123',
                   'class_name': 'cube',
                   'color': 'red',
                   'is_graspable': True
               }
           ],
           'spatial_constraints': {},
           'priority': 'medium'
       }

       print(f"Created test intent with {len(test_action_sequence)} actions")

       # Define callback for execution updates
       def execution_callback(status):
           print(f"Execution update: {json.dumps(status, indent=2)}")

       # Execute the intent
       print("\nStarting action sequence execution...")
       execution_id = vla_action_integrator.execute_intent_with_actions(
           test_intent,
           callback=execution_callback
       )

       print(f"Execution started with ID: {execution_id}")

       # Monitor execution progress
       print("\nMonitoring execution progress:")
       while True:
           status = vla_action_integrator.monitor_execution(execution_id)

           if status['status'] in ['success', 'failed', 'cancelled', 'not_found']:
               print(f"Execution completed with status: {status['status']}")
               if 'error_message' in status and status['error_message']:
                   print(f"Error: {status['error_message']}")
               break

           print(f"  Status: {status['status']}, Progress: {status['progress']:.2%}")
           time.sleep(1)  # Check every second

       # Get summary of active executions
       summary = vla_action_integrator.get_active_executions_summary()
       print(f"\nActive executions summary: {summary}")

       # Cleanup
       action_executor.destroy_node()
       rclpy.shutdown()
       print("\nAction execution system shutdown")

   if __name__ == "__main__":
       main()
   ```

3. **Testing**: Run the test script to see how the action execution system processes action sequences and manages execution states.

## Key Concepts

### ROS 2 Action Interfaces
- **Action Servers**: Provide long-running services with feedback and status
- **Action Clients**: Send goals to action servers and monitor progress
- **Goal Tracking**: Monitor the status of sent goals
- **Feedback Mechanisms**: Receive ongoing feedback during action execution

### Execution State Management
- **State Tracking**: Monitor progress through action sequences
- **Error Handling**: Detect and respond to action failures
- **Cancellation**: Allow users to stop running executions
- **Recovery**: Implement strategies for handling failed actions

### Integration with Simulation
- **Isaac Sim Interface**: Connect ROS 2 nodes with NVIDIA Isaac Sim
- **Physics Simulation**: Ensure actions respect physical constraints
- **Sensor Feedback**: Use simulated sensors for state verification

## Common Challenges and Solutions

### Challenge 1: Action Timeout Management
**Problem**: Actions may take longer than expected or hang indefinitely.
**Solution**: Implement proper timeout mechanisms and action cancellation.

### Challenge 2: State Synchronization
**Problem**: Robot state may not match expected state after actions.
**Solution**: Use feedback and state verification to ensure consistency.

### Challenge 3: Error Recovery
**Problem**: Actions may fail due to environmental conditions.
**Solution**: Implement retry logic and alternative action sequences.

## Assessment Questions

1. How does the action executor handle different types of actions (navigation vs manipulation)?
2. What is the role of the execution manager in tracking execution progress?
3. How does the system handle action failures during execution?
4. What are the key components of the ROS 2 action execution architecture?

## Summary

In this lesson, you have implemented the action execution component of the VLA system. You learned how to:
- Implement ROS 2 action clients for navigation and manipulation tasks
- Execute action sequences generated by the cognitive planner
- Monitor execution state and provide feedback to the VLA system
- Handle action failures and implement recovery procedures
- Integrate with simulation environments for safe testing

The action execution system serves as the muscle of the VLA pipeline, translating high-level plans into concrete robotic behaviors. In the next lesson, you will integrate all VLA components into a complete system and work on the capstone project.